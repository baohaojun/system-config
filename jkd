#!/usr/bin/env perl
# [[file:~/src/github/org-kungfu/jkd.org::the-ultimate-script][the-ultimate-script]]
use strict;
use String::ShellQuote;

## start code-generator "^\\s *#\\s *"
# generate-getopt -P -s perl -p jkd \
# '?subcmd_help()' \
# u:username='"$ENV{scm_jira_user}"' '?"Login Username"' \
# p:password='"$ENV{scm_jira_password}"' '?"Login Password"' \
# j:jiraurl='"$ENV{scm_jira_url}"' '?"Jira URL (only FQDN, no / and such)"' \
# vverbose='"$ENV{jkd_verbose}"' '?"Verbose debug output"'
## end code-generator
## start generated code
use Getopt::Long;

Getopt::Long::Configure("posix_default");



my $jkd_jiraurl = "$ENV{scm_jira_url}";
my $jkd_password = "$ENV{scm_jira_password}";
my $jkd_username = "$ENV{scm_jira_user}";
my $jkd_verbose = "$ENV{jkd_verbose}";

my $handler_help = sub {
    print subcmd_help();
    print "\n\n选项和参数：\n";
    printf "%6s", '-j, ';
    printf "%-24s", '--jiraurl=JIRAURL';
    if (length('--jiraurl=JIRAURL') > 24 and length("Jira URL (only FQDN, no / and such)") > 0) {
        print "\n";
        printf "%30s", "";
    }
    printf "%s", "Jira URL (only FQDN, no / and such)";
    print "\n";
    printf "%6s", '-p, ';
    printf "%-24s", '--password=PASSWORD';
    if (length('--password=PASSWORD') > 24 and length("Login Password") > 0) {
        print "\n";
        printf "%30s", "";
    }
    printf "%s", "Login Password";
    print "\n";
    printf "%6s", '-u, ';
    printf "%-24s", '--username=USERNAME';
    if (length('--username=USERNAME') > 24 and length("Login Username") > 0) {
        print "\n";
        printf "%30s", "";
    }
    printf "%s", "Login Username";
    print "\n";
    printf "%6s", '-v, ';
    printf "%-24s", '--[no]verbose';
    if (length('--[no]verbose') > 24 and length("Verbose debug output") > 0) {
        print "\n";
        printf "%30s", "";
    }
    printf "%s", "Verbose debug output";
    print "\n";

    exit(0);
};

GetOptions (
    'jiraurl|j=s' => \$jkd_jiraurl,
    'password|p=s' => \$jkd_password,
    'username|u=s' => \$jkd_username,
    'verbose|v!' => \$jkd_verbose,
    'help|h!' => \&$handler_help,
    );


## end generated code
use v5.10;
use String::ShellQuote;

if ($jkd_verbose) {
    say STDERR  "jkd ", shell_quote(@ARGV);
}

my $secret_conf;
use Config::GitLike;

my ($config_file) = $ENV{scm_secrets_conf};

if (-e $config_file) {
    $secret_conf = Config::GitLike->load_file($config_file);
}

if (not $jkd_password) {
    $jkd_password = $secret_conf->{"ldap.${jkd_username}.password"};
}

if (not $jkd_password) {
    say STDERR "Must specify the jira password";
    &$handler_help(1)
}

if (not $jkd_username) {
    $jkd_username = $secret_conf->{"jkd.username"};
}

if (not $jkd_username) {
    say STDERR  "Must specify the jira username";
    &$handler_help(1);
}

if (not $jkd_jiraurl) {
    $jkd_jiraurl = $secret_conf->{"jkd.jiraurl"};
}

if (not $jkd_jiraurl) {
    say STDERR  "Must specify the jira url";
    &$handler_help(1);
}

my $jkd_topdir = $secret_conf->{"jkd.topdir"};
if (not $jkd_topdir) {
    $jkd_topdir = glob("~/src/github/jkd-doujyou"); # doujyou is japanese for 道場
}

use File::Path;
make_path($jkd_topdir);
chdir($jkd_topdir)
    or die "Can't chdir: $jkd_topdir";

use JIRA::REST;

my $jira = JIRA::REST->new({
    url      => "$jkd_jiraurl",
    username => "$jkd_username",
    password => "$jkd_password"
                         });
use v5.10;
use HTTP::Request::Common;
use LWP::UserAgent;
use JSON;
use File::Path qw(make_path);
use File::Basename;
use Encode;

sub jkd_url_for_api($) {
    (my $api_path = $_[0]) =~ s,^/,,;

    my $auth_str = sprintf "%s:%s@", $jkd_username, $jkd_password;
    (my $scm_jira_site = $jkd_jiraurl) =~ s,(https?://),$1$auth_str,;
    my $url = "${scm_jira_site}${api_path}";
    if ($jkd_verbose) {
        say STDERR "api: $url";
    }

    return "$url";
}

sub get($) {
    my $ua = LWP::UserAgent->new;
    my $api = $_[0];
    my $url = jkd_url_for_api($api);

    my $response = $ua->request(GET $url);
    if ($response->code != 200) {
        die "Can't get $api: code is " . $response->code . ", url is $url";
    }


    return $response;
}

sub jkd_get($) {
    my $response = get($_[0]);
    print $response->content;
}

sub select_args(@) {
    if ($jkd_verbose) {
        say STDERR "select-args ", join(" ", shell_quote(@_));
    }
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l -P p:prompt O:order-name i:init-input
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("posix_default");

    local @ARGV = @_;

    my $init_input = "";
    my $order_name = "";
    my $prompt = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--init-input=INIT-INPUT';
        if (length('--init-input=INIT-INPUT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-O, ';
        printf "%-24s", '--order-name=ORDER-NAME';
        if (length('--order-name=ORDER-NAME') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-p, ';
        printf "%-24s", '--prompt=PROMPT';
        if (length('--prompt=PROMPT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'init-input|i=s' => \$init_input,
        'order-name|O=s' => \$order_name,
        'prompt|p=s' => \$prompt,
        'help|h!' => \&$handler_help,
        );


    ## end generated code

    my @command = (
        "select-args", "-p", "$prompt", "-i", "$init_input",
        "-O", "$order_name",
        @ARGV
        );

    my $command = join(" ", shell_quote(@command));
    my $res = qx($command);

    return $res;
}

sub jkd_q(@) {
    my $unset_jql = '!unset!';
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl q:jql='"$unset_jql"' pprint-all
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");



    my $jql = "$unset_jql";
    my $print_all = 0;

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-q, ';
        printf "%-24s", '--jql=JQL';
        if (length('--jql=JQL') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-p, ';
        printf "%-24s", '--[no]print-all';
        if (length('--[no]print-all') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'jql|q=s' => \$jql,
        'print-all|p!' => \$print_all,
        'help|h!' => \&$handler_help,
        );


    ## end generated code

    use URI::Escape;
    if ($jql eq $unset_jql) {
        if (@ARGV) {
            $jql = uri_escape(join(" ", @ARGV));
        } else {
            die "Must specify jql"
        }
    } else {
        if (@ARGV) {
            die "Extra args: ", join(" ", @ARGV);
        } else {
            $jql = uri_escape($jql);
        }
    }

    my $jql_content = get("rest/api/2/search?jql=$jql")->content;
    if ($print_all) {
        print "${jql_content}";
        exit 0;
    }

    my $jql_ret = decode_json $jql_content;
    my @issues;
    for my $issue (@{$jql_ret->{issues}}) {
        push @issues, sprintf "%s: %s (%s)", $issue->{key}, $issue->{fields}{summary}, $issue->{fields}{status}{statusCategory}{key};
    }
    my $selected_issue = select_args("-p", "which issue do you want?", sort {$a cmp $b} @issues);
    system("putclip", $selected_issue);
}

sub jkd_select_project(@) {
    my $projects_resp = get("rest/api/2/project/");

    my %project_key_name_map;
    my $projects_object = decode_json $projects_resp->content;

    for my $project (@{$projects_object}) {
        $project_key_name_map{$project->{key}} = $project->{name};
    }

    return select_args("-p", "Which project do you want to use?",
                "-O", "select-jira-project",
                sort {$a cmp $b} map {sprintf "%s: %s", $_, $project_key_name_map{$_}} keys %project_key_name_map
        );
}

sub jkd_get_issue_types(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l p:project ttest-it
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $project = "";
    my $test_it = 0;

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-p, ';
        printf "%-24s", '--project=PROJECT';
        if (length('--project=PROJECT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-t, ';
        printf "%-24s", '--[no]test-it';
        if (length('--[no]test-it') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'project|p=s' => \$project,
        'test-it|t!' => \$test_it,
        'help|h!' => \&$handler_help,
        );


    ## end generated code

    my $project_meta_resp = get("rest/api/2/issue/createmeta?projectKeys=$project");
    my %jkd_project_issue_types_name_id_map;

    my $project_meta_obj = decode_json $project_meta_resp->content;
    for my $project (@{$project_meta_obj->{projects}}) {
        for my $issuetype (@{$project->{issuetypes}}) {
            my $name = encode_utf8 $issuetype->{name};
            my $id = $issuetype->{id};
            $jkd_project_issue_types_name_id_map{$name} = $id;
        }
    }

    if ($test_it) {
        print join("\n",
                   map
                   {sprintf "%s: %s", $_, $jkd_project_issue_types_name_id_map{$_}}
                   keys %jkd_project_issue_types_name_id_map
            );
    }
    return %jkd_project_issue_types_name_id_map;
}

sub jkd_get_issue_type_field_names(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -P -l p:project t:issue-type
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("posix_default");

    local @ARGV = @_;

    my $issue_type = "";
    my $project = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-t, ';
        printf "%-24s", '--issue-type=ISSUE-TYPE';
        if (length('--issue-type=ISSUE-TYPE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-p, ';
        printf "%-24s", '--project=PROJECT';
        if (length('--project=PROJECT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'issue-type|t=s' => \$issue_type,
        'project|p=s' => \$project,
        'help|h!' => \&$handler_help,
    );


    ## end generated code

    my @fields = @ARGV;

    @ARGV = ();

    my $fields_json;
    if ($project and $issue_type) {
        $fields_json = decode_json(qx(jkd get-issue-type-fields -p $project -t '$issue_type' -v));
    } else {
        $fields_json = read_file("/dev/stdin");
    }

    use JSON::Path 'jpath_map';

    for (@fields) {
        my $jpath = JSON::Path->new("\$..$_.name");
        my $name = encode_utf8 $jpath->value($fields_json);
        say "$name : $_";
    }
}

sub jkd_get_issue_type_fields(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l p:project t:issue-type vverbose '?"print the json"'
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $issue_type = "";
    my $project = "";
    my $verbose = 0;

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-t, ';
        printf "%-24s", '--issue-type=ISSUE-TYPE';
        if (length('--issue-type=ISSUE-TYPE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-p, ';
        printf "%-24s", '--project=PROJECT';
        if (length('--project=PROJECT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-v, ';
        printf "%-24s", '--[no]verbose';
        if (length('--[no]verbose') > 24 and length("print the json") > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", "print the json";
        print "\n";

        exit(0);
    };

    GetOptions (
        'issue-type|t=s' => \$issue_type,
        'project|p=s' => \$project,
        'verbose|v!' => \$verbose,
        'help|h!' => \&$handler_help,
        );


    ## end generated code

    if (not $issue_type or not $issue_type =~ m/^\d+$/) {
        $issue_type = jkd_select_issue_type("-p", "$project", "-t", $issue_type);
    }

    my $issue_fields_resp = get("rest/api/2/issue/createmeta?projectKeys=${project}&issuetypeIds=${issue_type}&expand=projects.issuetypes.fields");

    print $issue_fields_resp->content if $verbose;
    return decode_json $issue_fields_resp->content;
}

use File::Slurp;

sub org_markdown_convert(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l @:text @:from @:to
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $from = "";
    my $text = "";
    my $to = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '';
        printf "%-24s", '--from=FROM';
        if (length('--from=FROM') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--text=TEXT';
        if (length('--text=TEXT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--to=TO';
        if (length('--to=TO') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'from=s' => \$from,
        'text=s' => \$text,
        'to=s' => \$to,
        'help|h!' => \&$handler_help,
        );


    ## end generated code
    if (not $text) {
        return "";
    }

    chomp(my $tmp_file = qx(mktemp));
    write_file($tmp_file, $text);
    my $res = qx(pandoc -f $from -t $to $tmp_file);
    unlink($tmp_file);
    return $res;
}

sub org_to_markdown($) {
    return org_markdown_convert("--from", "org", "--to", "markdown", "--text", $_[0]);
}

sub markdown_to_org($) {
    return org_markdown_convert("--to", "org", "--from", "markdown", "--text", $_[0]);
}

sub work_with_all_fields($$\%$) {
    my ($project_id, $issue_type_id, $required_fields, $work_options) = @_;
    my $edit_issue_json_obj = $work_options->{edit_issue_json_obj};
    my $print_schemes = $work_options->{"print-schemes"};
    my $issue_fields_obj = jkd_get_issue_type_fields("-p", "$project_id", "-t", "$issue_type_id");


    for my $project (@{$issue_fields_obj->{projects}}) {
        for my $it (@{$project->{issuetypes}}) {
            if ($it->{id} != $issue_type_id) {
                next;
            }

            my @fields_to_edit;
            if ($edit_issue_json_obj) {
                my @command = (
                    "select-args-n", "-p", decode_utf8("请输入你想要编辑的域"),
                    map {
                        sprintf "%s: %s", $_, $it->{fields}{$_}{name}
                    }
                    grep {
                        $it->{fields}{$_}{required}
                    } sort keys %{$it->{fields}}
                    );
                my $command = join(" ", shell_quote(@command));
                my $values = decode_utf8 qx($command);
                $values =~ s,:.*,,mg;
                @fields_to_edit = split(" ", $values);
                say STDERR "fields_to_edit is @fields_to_edit";


            } else {
                @fields_to_edit = sort keys %{$it->{fields}};
            }

            $required_fields->{assignee} = '' if exists $it->{fields}{assignee} and not $edit_issue_json_obj;

            for my $field_key (@fields_to_edit) {
                if ($it->{fields}{$field_key}{required}) {
                    if ($field_key eq 'project' || $field_key eq 'issuetype') {
                        next;
                    }
                    my $field_name = encode_utf8($it->{fields}{$field_key}{name} or "$field_key (field has no name)");

                    say STDERR "field ${field_name}'s value is ", encode_utf8($edit_issue_json_obj->{fields}{$field_key} || "");

                    if ($print_schemes) {
                        print "--field-value $field_name= ";
                        next;
                    }


                    if ($required_fields->{$field_name}) {
                        $required_fields->{$field_key} = $required_fields->{$field_name};
                        delete $required_fields->{$field_name} unless ${field_key} eq ${field_name};
                        next;
                    }

                    my $schema_type = $it->{fields}{$field_key}{schema}{type};

                    my %selection_types = (
                        array => 1,
                        option => 1,
                    );


                    if ($schema_type eq 'string') {
                        my @command = (
                            "ask-for-input-with-emacs", "-p", sprintf("Please input the %s (field key: %s)", $field_name, $field_key),
                            "--init-text", markdown_to_org encode_utf8($edit_issue_json_obj->{fields}{$field_key} || "")
                            );
                        my $command = join(" ", shell_quote(@command));
                        say "command is $command";

                        $required_fields->{$field_key} = decode_utf8 org_to_markdown qx($command);
                    } elsif ($selection_types{$schema_type}) {
                        my %allowed_values_map;
                        map {
                            my $key = $_->{value} || $_->{name};
                            $allowed_values_map{$key} = $_->{id}} @{$it->{fields}{$field_key}{allowedValues}};

                        my $select_command;

                        if ($schema_type eq "array") {
                            $select_command = "select-args-n";
                        } else {
                            $select_command = "select-args";
                        }
                        my @command = (
                            $select_command, "-p", decode_utf8("请输入你想要选择的 " . "$field_name"),
                            keys %allowed_values_map
                            );
                        my $command = join(" ", shell_quote(@command));
                        my $values = decode_utf8 qx($command);
                        $required_fields->{$field_key} = [] if $schema_type eq "array";
                        for (split "\n", $values) {
                            next unless $_;
                            say "Adding option for $field_name: ", encode_utf8 $_;
                            die "invalid $_" unless ${allowed_values_map{$_}};
                            if ($schema_type eq "array") {
                                push @{$required_fields->{$field_key}}, {id => $allowed_values_map{$_}};
                            } else {
                                $required_fields->{$field_key} = {id => $allowed_values_map{$_}};
                            }

                        }
                    } else {
                        my $jsonParser = JSON->new->allow_nonref;
                        my $json = $jsonParser->utf8->pretty->encode($it->{fields}{$field_key});
                        say <<EOF;

$json

Don't know how to deal with ${field_name}, please input with json.

EOF
                        while (1) {
                            $required_fields->{$field_key} = eval 'decode_json(qx(ask-for-input -p "what is your input json?"))';
                            last unless $@;
                        }
                    }
                }
            }
        }
    }
    if ($print_schemes) {
        exit;
    }
}

sub get_issue_type($$$) {
    my ($projects_issuetypes, $project_id, $issue_type_id) = @_;
    for (@{$projects_issuetypes->{projects}}) {
        if ($_->{id} == $project_id || $_->{key} eq $project_id) {
            for (@{$_->{issuetypes}}) {
                if ($_->{id} == $issue_type_id) {
                    return $_;
                }
            }
        }
    }
}

sub getNormalizedName($) {
    my $name = $_[0];

    $name =~ s, | ,,g;
    return $name;
}

sub jkd_print_issue(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl i:issue f:fields-to-print='()' @json @for-clone
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");



    my @fields_to_print = ();
    my $for_clone = 0;
    my $issue = "";
    my $json = 0;

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-f, ';
        printf "%-24s", '--fields-to-print=FIELDS-TO-PRINT';
        if (length('--fields-to-print=FIELDS-TO-PRINT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--[no]for-clone';
        if (length('--[no]for-clone') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue=ISSUE';
        if (length('--issue=ISSUE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--[no]json';
        if (length('--[no]json') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'fields-to-print|f=s' => \@fields_to_print,
        'for-clone!' => \$for_clone,
        'issue|i=s' => \$issue,
        'json!' => \$json,
        'help|h!' => \&$handler_help,
    );


    ## end generated code

    my $json_issue = decode_json get("rest/api/2/issue/$issue?expand=names")->content;
    if ($json and not @fields_to_print) {
        if (not $for_clone) {
            for (keys %{$json_issue->{fields}}) {
                my $name = $json_issue->{names}{$_};
                if ($name) {
                    if (ref $json_issue->{fields}{$_} ne "HASH") {
                        my $val = $json_issue->{fields}{$_};
                        $json_issue->{fields}{$_} = {};
                        $json_issue->{fields}{$_}{jkd_value} = $val;
                    }
                    $json_issue->{fields}{$_} = {} unless $json_issue->{fields}{$_};

                    if (0) {    # for debugging
                        say STDERR sprintf(
                            "name is %s, _ is %s, %s",
                            encode_utf8($name),
                            encode_utf8($_),
                            encode_json($json_issue->{fields}{$_})
                        );
                    }

                    $json_issue->{fields}{$_}{jkd_name} = $name;
                    delete $json_issue->{names}{$_};
                }
            }
            print encode_json($json_issue);
        } else {
            my %fields;
            for (keys %{$json_issue->{fields}}) {
                if ($json_issue->{fields}{$_}) {
                    my $name = $json_issue->{names}{$_};
                    if ($name) {
                        $fields{$_} = $json_issue->{fields}{$_};
                    } else {
                        $fields{$_} = $json_issue->{fields}{$_};
                    }

                }
            }
            print encode_json \%fields;
        }
        exit;
    }
    my $issue_type_id = $json_issue->{fields}{issuetype}{id};
    my $issue_project = $json_issue->{fields}{project}{key};

    my @all_fields = sort keys %{$json_issue->{fields}};

    my %fields_to_print;

    my %fields_to_print_normalized;
    my %fields_results;

    for (@fields_to_print) {
        $fields_to_print{$_} = 1;
        $fields_to_print_normalized{getNormalizedName $_} = $_;
    }

    my $jsonParser = JSON->new->allow_nonref;

    for (@all_fields) {
        my $field_name = getNormalizedName encode_utf8 $json_issue->{names}{$_};
        say STDERR "working with $field_name" if $jkd_verbose;

        next unless $json_issue->{fields}{$_};
        if ($fields_to_print{$_} or $fields_to_print_normalized{$field_name} or not @fields_to_print) {
            if (@fields_to_print == 1 and not $json) {
                use Data::Types qw(:string);
                my $value = $json_issue->{fields}{$_};
                if (is_string $value) {
                    say $value;
                } else {
                    say $jsonParser->utf8->pretty->encode($value);
                }
            } else {
                if ($fields_to_print{$_}) {
                    $fields_results{decode_utf8 $_} = $json_issue->{fields}{$_}
                } elsif ($fields_to_print_normalized{$field_name}) {
                    $fields_results{decode_utf8 $fields_to_print_normalized{$field_name}} = $json_issue->{fields}{$_}
                }
            }
        }
    }
    if (%fields_results) {
        print $jsonParser->utf8->pretty->encode (\%fields_results);
    }
}

sub jkd_e(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl i:issue-to-edit f:field-to-edit @:fields-json='"{}"'
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");



    my $field_to_edit = "";
    my $fields_json = "{}";
    my $issue_to_edit = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-f, ';
        printf "%-24s", '--field-to-edit=FIELD-TO-EDIT';
        if (length('--field-to-edit=FIELD-TO-EDIT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--fields-json=FIELDS-JSON';
        if (length('--fields-json=FIELDS-JSON') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue-to-edit=ISSUE-TO-EDIT';
        if (length('--issue-to-edit=ISSUE-TO-EDIT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'field-to-edit|f=s' => \$field_to_edit,
        'fields-json=s' => \$fields_json,
        'issue-to-edit|i=s' => \$issue_to_edit,
        'help|h!' => \&$handler_help,
    );


    ## end generated code

    if (not $issue_to_edit) {
        die "You must specify -issue-to-edit";
    }

    my $json_issue = decode_json get("rest/api/2/issue/$issue_to_edit")->content;
    my $issue_type_id = $json_issue->{fields}{issuetype}{id};
    my $issue_project = $json_issue->{fields}{project}{key};
    my $issue_fields_obj = jkd_get_issue_type_fields("-p", "$issue_project", "-t", "$issue_type_id");

    my %edited_fields;

    if ($fields_json eq "{}") {
        work_with_all_fields(
            $issue_project, $issue_type_id, %edited_fields,
            {
                edit_issue_json_obj => $json_issue,
            });
    } else {
        my $issue_fields_obj = decode_json get("rest/api/2/issue/${issue_to_edit}?expand=names")->content;
        my $fields_json_obj = decode_json $fields_json;
        update_names_with_fields($fields_json_obj, $issue_fields_obj->{names});
        %edited_fields = %$fields_json_obj;
    }


    my $ua = LWP::UserAgent->new;

    my $request = PUT jkd_url_for_api("rest/api/2/issue/$issue_to_edit"),
        'Content-Type' => 'application/json',
        'Accept' => 'application/json',
        "charset" => "utf-8",
        Content => encode_json {
            fields => \%edited_fields
    };
    my $response = $ua->request($request);

    say "PUT response code:" . $response->code, "result: ", $response->content;
}

sub jkd_resolve(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -P i:issue-to-edit r:resolution
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("posix_default");



    my $issue_to_edit = "";
    my $resolution = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue-to-edit=ISSUE-TO-EDIT';
        if (length('--issue-to-edit=ISSUE-TO-EDIT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-r, ';
        printf "%-24s", '--resolution=RESOLUTION';
        if (length('--resolution=RESOLUTION') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'issue-to-edit|i=s' => \$issue_to_edit,
        'resolution|r=s' => \$resolution,
        'help|h!' => \&$handler_help,
    );


    ## end generated code

    my $ua = LWP::UserAgent->new;

    my $request = PUT jkd_url_for_api("rest/api/2/issue/$issue_to_edit"),
        'Content-Type' => 'application/json',
        'Accept' => 'application/json',
        "charset" => "utf-8",
        Content => encode_json {
            fields => {
                resolution => {
                    id => 10300
                }
            }
        };
    my $response = $ua->request($request);

    say "PUT response code:" . $response->code, "result: ", $response->content;
}

sub jkd_select_issue_type(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l p:project t:issue-type
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $issue_type = "";
    my $project = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-t, ';
        printf "%-24s", '--issue-type=ISSUE-TYPE';
        if (length('--issue-type=ISSUE-TYPE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-p, ';
        printf "%-24s", '--project=PROJECT';
        if (length('--project=PROJECT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'issue-type|t=s' => \$issue_type,
        'project|p=s' => \$project,
        'help|h!' => \&$handler_help,
        );


    ## end generated code

    my %jkd_project_issue_types_name_id_map = jkd_get_issue_types("-p", $project);
    my $issue_type_name = $issue_type || select_args("-p", "Which type of issue do you want?", "-O", "select-issue-type", sort {$a cmp $b} keys %jkd_project_issue_types_name_id_map);
    my $issue_type_id = $jkd_project_issue_types_name_id_map{$issue_type_name};
    say STDERR "issue_type_id is $issue_type_id, issue_type_name is '$issue_type_name'";
    return $issue_type_id;
}

sub jkd_c(@) { # create issue

    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l \
    #     p:project \
    #     t:issue-type '?"指定要创建的 issue 类型，比如 bug、feature、story 等（取决于 project）"' \
    #     @assign-to-myself=1 \
    #     @:field-value='()' \
    #     @print-schemes \
    #     @:fields-json
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $assign_to_myself = 1;
    my @field_value = ();
    my $fields_json = "";
    my $issue_type = "";
    my $print_schemes = 0;
    my $project = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '';
        printf "%-24s", '--[no]assign-to-myself';
        if (length('--[no]assign-to-myself') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--field-value=FIELD-VALUE';
        if (length('--field-value=FIELD-VALUE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--fields-json=FIELDS-JSON';
        if (length('--fields-json=FIELDS-JSON') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-t, ';
        printf "%-24s", '--issue-type=ISSUE-TYPE';
        if (length('--issue-type=ISSUE-TYPE') > 24 and length("指定要创建的 issue 类型，比如 bug、feature、story 等（取决于 project）") > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", "指定要创建的 issue 类型，比如 bug、feature、story 等（取决于 project）";
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--[no]print-schemes';
        if (length('--[no]print-schemes') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-p, ';
        printf "%-24s", '--project=PROJECT';
        if (length('--project=PROJECT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'assign-to-myself!' => \$assign_to_myself,
        'field-value=s' => \@field_value,
        'fields-json=s' => \$fields_json,
        'issue-type|t=s' => \$issue_type,
        'print-schemes!' => \$print_schemes,
        'project|p=s' => \$project,
        'help|h!' => \&$handler_help,
    );


    ## end generated code

    if (not $project) {
        ($project = jkd_select_project()) =~ s/:.*//;
    }

    if (not $issue_type or not $issue_type =~ m/^\d+$/) {
        $issue_type = jkd_select_issue_type("-p", $project, "-t", "$issue_type");
    }

    my %required_fields;

    for (@field_value) {
        if (m/(.*?)=(.*)/) {
            my ($field, $value) = ($1, $2);
            $required_fields{$field} = decode_utf8 $value;
        } else {
            die "$_ not format of FIELD=VALUE?"
        }
    }

    if ( $fields_json) {
        my $required_fields = decode_json $fields_json;
        %required_fields = %$required_fields;
        $required_fields{project} = {
            key => $project,
        };

        $required_fields{issuetype} = {
            id => $issue_type,
        };

    } else {
        work_with_all_fields($project, $issue_type, %required_fields, {"print-schemes" => ${print_schemes}});

        $required_fields{project} = {
            key => $project,
        };

        $required_fields{issuetype} = {
            id => $issue_type,
        };
    }
    if ($assign_to_myself and exists $required_fields{assignee}) {
        $required_fields{assignee} = {
            name => $ENV{scm_jira_user}
        };
    } else {
        delete $required_fields{assignee};
    }

    my $ua = LWP::UserAgent->new;
    say "json is ", encode_json { fields => \%required_fields } if $jkd_verbose;

    for (my $try = 0; $try < 2; $try++) {
        my $request = POST jkd_url_for_api("rest/api/2/issue"),
            'Content-Type' => 'application/json',
            'Accept' => 'application/json',
            "charset" => "utf-8",
            Content => encode_json {
                fields => \%required_fields,
            };
        my $response = $ua->request($request);

        say "POST response code:" . $response->code, "result: ", $response->content;

        last if $response->is_success;

        my $errors = decode_json($response->content)->{errors};
        for (keys %$errors) {
            # die "Can't find $_" unless $required_fields{$_};
            delete $required_fields{$_};
        }
    }
}

sub jkd_comment(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -l -s perl i:issue c:comment @once '?"以前已经添加过的 comment，就不会再重复添加了"'
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $comment = "";
    my $issue = "";
    my $once = 0;

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-c, ';
        printf "%-24s", '--comment=COMMENT';
        if (length('--comment=COMMENT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue=ISSUE';
        if (length('--issue=ISSUE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--[no]once';
        if (length('--[no]once') > 24 and length("以前已经添加过的 comment，就不会再重复添加了") > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", "以前已经添加过的 comment，就不会再重复添加了";
        print "\n";

        exit(0);
    };

    GetOptions (
        'comment|c=s' => \$comment,
        'issue|i=s' => \$issue,
        'once!' => \$once,
        'help|h!' => \&$handler_help,
    );


    ## end generated code

    if ($once) {
        my $jira_issue = $jira->GET("/issue/$issue");
        for (@{$jira_issue->{fields}{comment}{comments}}) {
            if (encode_utf8 $_->{body} eq "$comment") {
                say "$comment already exists";
                exit 0;
            }
        }
    }

    my $ua = LWP::UserAgent->new;

    my $request = PUT jkd_url_for_api("rest/api/2/issue/${issue}"),
        'Content-Type' => 'application/json',
        'Accept' => 'application/json',
        "charset" => "utf-8",
        Content => encode_json {
            update => {
                comment => [
                    {
                        add =>
                        {
                            body => decode_utf8 $comment
                        }
                    }
                    ]
            }
    };
    my $res = $ua->request($request);

    say "PUT res code:" . $res->code, "result: ", $res->content;
    die sprintf("invalid request result: code = %d, content = '%s'", $res->code, $res->content) if ($res->code < 200 or $res->code >= 300);

}

sub jkd_get_comment(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l -P i:issue n:nth-comment=-1 c:comment '?"如果指定，在注释中找到此参数的话，即退出"'
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("posix_default");

    local @ARGV = @_;

    my $comment = "";
    my $issue = "";
    my $nth_comment = -1;

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-c, ';
        printf "%-24s", '--comment=COMMENT';
        if (length('--comment=COMMENT') > 24 and length("如果指定，在注释中找到此参数的话，即退出") > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", "如果指定，在注释中找到此参数的话，即退出";
        print "\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue=ISSUE';
        if (length('--issue=ISSUE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-n, ';
        printf "%-24s", '--nth-comment=NTH-COMMENT';
        if (length('--nth-comment=NTH-COMMENT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'comment|c=s' => \$comment,
        'issue|i=s' => \$issue,
        'nth-comment|n=s' => \$nth_comment,
        'help|h!' => \&$handler_help,
        );


    ## end generated code
    my $jira_issue = $jira->GET("/issue/$issue");
    if ($comment) {
        for (@{$jira_issue->{fields}{comment}{comments}}) {
            if (encode_utf8 $_->{body} eq "$comment") {
                exit 0;
            }
        }
        exit 1;
    }

    print encode_utf8 $jira_issue->{fields}{comment}{comments}[$nth_comment]{body};
}

sub jkd_assign(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l i:issue-id a:assign-to
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $assign_to = "";
    my $issue_id = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-a, ';
        printf "%-24s", '--assign-to=ASSIGN-TO';
        if (length('--assign-to=ASSIGN-TO') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue-id=ISSUE-ID';
        if (length('--issue-id=ISSUE-ID') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'assign-to|a=s' => \$assign_to,
        'issue-id|i=s' => \$issue_id,
        'help|h!' => \&$handler_help,
        );


    ## end generated code

    my $ua = LWP::UserAgent->new;

    my $request = PUT jkd_url_for_api("rest/api/2/issue/${issue_id}/assignee"),
        'Content-Type' => 'application/json',
        'Accept' => 'application/json',
        "charset" => "utf-8",
        Content => encode_json {
            name => $assign_to
    };

    my $response = $ua->request($request);

    if ($response->code < 200 || $response->code >= 300) {
        use HTTP::Status;
        say sprintf("PUT error! response code: %d (meaning: %s), content: %s", $response->code, status_message($response->code), $response->content);
    }
}

use HTTP::Request::Common;
use LWP::UserAgent;
use JSON;


sub jkd_mits(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -s perl -l i:issue s:sprint b:board
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $board = "";
    my $issue = "";
    my $sprint = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '-b, ';
        printf "%-24s", '--board=BOARD';
        if (length('--board=BOARD') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue=ISSUE';
        if (length('--issue=ISSUE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-s, ';
        printf "%-24s", '--sprint=SPRINT';
        if (length('--sprint=SPRINT') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'board|b=s' => \$board,
        'issue|i=s' => \$issue,
        'sprint|s=s' => \$sprint,
        'help|h!' => \&$handler_help,
        );


    ## end generated code

    use v5.10;

    if (not $sprint) {
        if (not $board or $board !~ m/^\d+$/) {
            my $json_boards = decode_json get("rest/agile/1.0/board/")->content;
            $board = select_args("-i", $board, "-p", "which board do you want? (should be scrum, not kanban)", sort {$a cmp $b} map {sprintf "%s: %s", $_->{id}, encode_utf8 $_->{name}} @{$json_boards->{values}});
            $board =~ s,:.*,,;
        }
        if ($board) {
            my $json_sprints = decode_json get("rest/agile/1.0/board/$board/sprint")->content;
            $sprint = $json_sprints->{values}[-1]{id};
        } else {
            die "Must specify one of sprint or board, when using board, the last sprint will be used";
        }
    }

    my $ua = LWP::UserAgent->new;

    my $request = POST jkd_url_for_api("/rest/agile/1.0/sprint/${sprint}/issue"),
        'Content-Type' => 'application/json',
        'Accept' => 'application/json',
        "charset" => "utf-8",
        Content => encode_json {
            issues => [
                "$issue"
                ]
    };
    my $response = $ua->request($request);

    say "POST response code:" . $response->code, "result: ", $response->content;


}
use v5.10;

sub update_names_with_fields($$) {
    my ($named_obj, $fields_map) = @_;

    my %name_field_map;

    for (keys %$fields_map) {
        my $name = $fields_map->{$_};

        if (ref $name) {
            $name = $name->{name};
        }

        if ($name) {
            $name = getNormalizedName encode_utf8 $name;

            $name_field_map{$name} = $_;
            say STDERR "Created a map: $name: $name_field_map{$name}";
        }

    }


    for (keys %$named_obj) {

        my $name = getNormalizedName encode_utf8 $_;
        say STDERR "working with specified name: $name: $name_field_map{$name}";


        if ($name_field_map{$name} and $name_field_map{$name} ne $_) {
            say STDERR "update $name with $name_field_map{$name}";
            $named_obj->{$name_field_map{$name}} = $named_obj->{$_};
            delete $named_obj->{$_};
        }
    }
}

sub jkd_tri(@) {
    ## start code-generator "^\\s *#\\s *"
    # generate-getopt -l -s perl i:issue t:transition @:fields-json='"{}"' @print-trans
    ## end code-generator
    ## start generated code
    use Getopt::Long;

    Getopt::Long::Configure("default");

    local @ARGV = @_;

    my $fields_json = "{}";
    my $issue = "";
    my $print_trans = 0;
    my $transition = "";

    my $handler_help = sub {
        print ;
        print "\n\n选项和参数：\n";
        printf "%6s", '';
        printf "%-24s", '--fields-json=FIELDS-JSON';
        if (length('--fields-json=FIELDS-JSON') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-i, ';
        printf "%-24s", '--issue=ISSUE';
        if (length('--issue=ISSUE') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '';
        printf "%-24s", '--[no]print-trans';
        if (length('--[no]print-trans') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";
        printf "%6s", '-t, ';
        printf "%-24s", '--transition=TRANSITION';
        if (length('--transition=TRANSITION') > 24 and length() > 0) {
            print "\n";
            printf "%30s", "";
        }
        printf "%s", ;
        print "\n";

        exit(0);
    };

    GetOptions (
        'fields-json=s' => \$fields_json,
        'issue|i=s' => \$issue,
        'print-trans!' => \$print_trans,
        'transition|t=s' => \$transition,
        'help|h!' => \&$handler_help,
    );


    ## end generated code

    if (not $issue) {
        say "must specify the issue";
        &$handler_help();
    }

    my $transision_json_obj;

    if ($transition !~ m/^\d+$/ or $fields_json ne "{}") {
        my $response = get("rest/api/2/issue/${issue}/transitions?expand=transitions.fields");
        if ($print_trans) {
            print $response->content;
            exit;
        }
        $transision_json_obj = decode_json $response->content;
    }

    my $fields_json_obj = decode_json $fields_json;
    if ($fields_json ne "{}") {
        update_names_with_fields($fields_json_obj, $transision_json_obj->{transitions}[0]{fields});
    }

    my $transition_name = $transition;

    unless ($transition =~ m/^\d+$/) {
        my $json_obj = $transision_json_obj;
        $transition = select_args("-p", decode_utf8 ("如何变更当前 issue：${issue}"), "-i", decode_utf8("$transition"), map {sprintf "id=%s: name=%s", $_->{id}, $_->{name}} @{$json_obj->{transitions}});
        $transition_name = $transition;
        say "transition is $transition";
        $transition =~ s,^id=(\d+):.*,$1, or
            die "Invalid transision $transition";
    }

    my $ua = LWP::UserAgent->new;

    for (my $try = 0; $try < 2; $try++) {
        my $request = POST jkd_url_for_api("rest/api/2/issue/${issue}/transitions"),
            'Content-Type' => 'application/json',
            'Accept' => 'application/json',
            "charset" => "utf-8",
            Content => encode_json {
                transition => {
                    id => $transition
                },
                fields => $fields_json_obj
            };
        say("my request's content: ", $request->content) if $jkd_verbose;
        my $response = $ua->request($request);

        if ($response->is_success) {
            say STDERR "Tri to '$transition_name' 成功了，正常退出";
            last;
        };

        say "PUT response code:" . $response->code, "result: ", $response->content;

        my $errors = decode_json($response->content)->{errors};
        for (keys %$errors) {
            delete $fields_json_obj->{$_};
        }
        die "Can't tri it after $try times" if ($try == 2);
    }

}
sub subcmd_help() {
    my $top_help_str = <<~'EOF';
        Usage: jkd [GLOBAL_OPTIONS]... SUB_COMMAND SUBCMD_ARGS...
        Here's the list of sub-commands:
        EOF

    my @subcmd_help_strs;
    my %subcmd_helpstr_map = (
        e => "Edit jira issue in emacs org-mode",
        tri => "Transition of an issue",
        );

    my %help_printed_map;

    for my $subcmd ((sort {$a cmp $b} grep {m/^jkd_/} keys %::), (sort {$a cmp $b} keys %subcmd_helpstr_map)) {
        (my $raw_subcmd = $subcmd) =~ s,^jkd_,,;
        $subcmd = "jkd_$raw_subcmd";
        if ($help_printed_map{$raw_subcmd}) {
            next;
        } else {
            $help_printed_map{$raw_subcmd} = 1;
        }

        my $subcmd_help_str = $subcmd_helpstr_map{$raw_subcmd} ||
            "NO DESCRIPTION.";

        if (not defined &$subcmd) {
            $subcmd_help_str .= " (NO DEFINITION)"
        }

        push @subcmd_help_strs, sprintf("    %s\n\t%s", $raw_subcmd, $subcmd_help_str);
    }

    return join "\n", $top_help_str, @subcmd_help_strs;
}
(my $sub_command = "jkd_" . shift) =~ s,-,_,g;


if (not defined &$sub_command) {
    say "Can't find sub-command: $sub_command";
    &$handler_help();
}

$sub_command = \&{$sub_command};
&$sub_command(@ARGV);

# Local Variables: #
# eval: (read-only-mode 1) #
# End: #
# Local Variables: #
# eval: (read-only-mode 1) #
# End: #
# the-ultimate-script ends here
