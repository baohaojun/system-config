<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>beagrep, grep 2G source code in 2 seconds</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="beagrep, grep 2G source code in 2 seconds"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-09-21 18:44:53 CST"/>
<meta name="author" content="Bao Haojun"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<link rel="stylesheet" href="css/default.css" type="text/css">
 <link rel="shortcut icon" href="/poison.png" type="image/png" />

    <script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript">
        var BYB = {};
    </script>
    <script type="text/javascript">
        BYB.includeScript = function(file,callback){
            var _doc = document.getElementsByTagName('head')[0];
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', file);
            _doc.appendChild(js);

            if (!/*@cc_on!@*/0) { //if not IE
                //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
                js.onload = function () {
                    callback();
                }
            } else {
                //IE6、IE7 support js.onreadystatechange
                js.onreadystatechange = function () {
                    if (js.readyState == 'loaded' || js.readyState == 'complete') {
                        callback();
                    }
                }
            }
            return false;
        }
    </script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">beagrep, grep 2G source code in 2 seconds</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Introduction</a></li>
<li><a href="#sec-2">2 Install</a>
<ul>
<li><a href="#sec-2-1">2.1 Linux install</a>
<ul>
<li><a href="#sec-2-1-1">2.1.1 Using .deb under debian/ubuntu</a></li>
<li><a href="#sec-2-1-2">2.1.2 Compile by yourself</a></li>
</ul>
</li>
<li><a href="#sec-2-2">2.2 Windows install</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1 Install dependencies</a></li>
<li><a href="#sec-2-2-2">2.2.2 Get beagrep Windows code</a></li>
<li><a href="#sec-2-2-3">2.2.3 Compile and install</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3">3 Usage</a>
<ul>
<li><a href="#sec-3-1">3.1 Quick smoke test</a></li>
<li><a href="#sec-3-2">3.2 Create index</a></li>
<li><a href="#sec-3-3">3.3 Man page for mkbeagrepidx</a></li>
<li><a href="#sec-3-4">3.4 Searching using beagrep</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1 Man page for beagrep</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4">4 How does it work?</a>
<ul>
<li><a href="#sec-4-1">4.1 grep patterns are usually simple</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1 BTW, creating the regexp pattern automatically in Emacs</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2 grep keywords are usually interesting</a></li>
</ul>
</li>
<li><a href="#sec-5">5 Other projects using beagrep</a>
<ul>
<li><a href="#sec-5-1">5.1 offline Wikipedia</a></li>
<li><a href="#sec-5-2">5.2 <code>grep-func-call</code> and <code>grep-func-call-all</code></a></li>
<li><a href="#sec-5-3">5.3 Generate call graph</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">


<p>
I still remember when I read the ``Linux Device Drivers'', 1st Edition, in the preface, the author says:
</p>
<blockquote>

<p>&hellip; The text you are approaching is the result of hours of patient grepping &hellip;
</p>
</blockquote>


<p>
I have been using grep to read source code ever since. It's been
adequate for a long time, until I started reading Android source code
with it. I remember vividly how it took me 30 minutes to <code>grep readlink</code> in Android source code (with VCS directory and binary files
excluded).
</p>
<p>
Then I learned about the beagle software, and it occurred to me, what
if I use beagle and grep together? I mean, to use beagle first to
decide the (relatively a lot smaller) set of possible matching files
(i.e., files that contained the word <code>readlink</code>, taking the previous
example), then invoke grep on this set only. Usually the job can be
done in a couple of seconds.
</p>
<p>
Beagrep supports both Linux and Windows (requires CYGWIN).
</p>
<p>
(Note a Chinese version of this page is available <a href="http://baohaojun.github.com/beagrep-cn.html">here</a>, but it may be
outdated).
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Install</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Linux install</h3>
<div class="outline-text-3" id="text-2-1">



</div>

<div id="outline-container-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Using .deb under debian/ubuntu</h4>
<div class="outline-text-4" id="text-2-1-1">


<p>
I have provided 4 .deb package files on github, one for debian
testing, 3 for ubuntu lucid(10.04), oneiric(11.10) and
precise(12.04). They are all for amd64. If you happen to be using one
of these, you can download them <a href="https://github.com/baohaojun/beagrep/downloads">here</a>. Here's how to install it using
ubuntu 12.04 as an example:
</p>



<pre class="src src-sh">dpkg -i beagrep-for-ubuntu-precise-2012-09-05-ae0a1a2.deb <span class="org-comment-delimiter"># </span><span class="org-comment">will probably get dependency errors</span>
apt-get -f install <span class="org-comment-delimiter"># </span><span class="org-comment">fix the dependency errors</span>
</pre>


</div>

</div>

<div id="outline-container-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Compile by yourself</h4>
<div class="outline-text-4" id="text-2-1-2">


<p>
If you need compile by yourself, using Ubuntu precise as an example:
</p>



<pre class="src src-sh">git clone https://github.com/baohaojun/beagrep.git -b for-ubuntu-precise
<span class="org-comment-delimiter"># </span><span class="org-comment">you can also run "git branch -a" to see other versions of debian/ubuntu supported</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Install build dependencies. You can open debian/control and check</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">the build dependencies and install all of them. The following</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">command will try to install them automatically, but if it fails then</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">you need figure out which packages to install manually. Good luck!</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Or you can contact some debian/ubuntu advanced user for help.</span>
apt-get install $(<span class="org-sh-quoted-exec">cat</span> debian/control | perl -ne <span class="org-string">'print if m/Build-Depends/..m/Standards-Version/'</span>|grep -v -e Build-Depends:<span class="org-string">\\\|</span>Standards-Version|perl -npe <span class="org-string">'s/,/ /g'</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">do the build</span>
(<span class="org-builtin">set</span> -e; autoreconf -i; ./configure; make -j4; sudo make install; <span class="org-builtin">echo</span> OK)
</pre>


</div>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Windows install</h3>
<div class="outline-text-3" id="text-2-2">


<p>
Windows install can only be done compiling by yourself, and be
pre-warned, it's not easy&hellip;
</p>

</div>

<div id="outline-container-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Install dependencies</h4>
<div class="outline-text-4" id="text-2-2-1">


<p>
You need install CYGWIN and Mono for Windows.
</p>
</div>

</div>

<div id="outline-container-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> Get beagrep Windows code</h4>
<div class="outline-text-4" id="text-2-2-2">





<pre class="src src-sh">git clone git://github.com/baohaojun/beagrep.git -b Windows
</pre>


</div>

</div>

<div id="outline-container-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> Compile and install</h4>
<div class="outline-text-4" id="text-2-2-3">





<pre class="src src-sh"><span class="org-builtin">cd</span> beagrep
bash build-win.sh
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Usage</h2>
<div class="outline-text-2" id="text-3">



</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Quick smoke test</h3>
<div class="outline-text-3" id="text-3-1">




<pre class="src src-sh"><span class="org-builtin">cd</span> /tmp; mkdir $<span class="org-variable-name">$</span>; <span class="org-builtin">cd</span> $<span class="org-variable-name">$</span>; <span class="org-builtin">echo</span> main &gt; 1.txt; mkbeagrepidx; beagrep -e <span class="org-string">'main'</span> --grep <span class="org-string">'--color=auto'</span>; true; <span class="org-builtin">cd</span> ..; rm $<span class="org-variable-name">$</span> -rf
</pre>


<p>
If beagrep has been installed correctly, at the end of the above
command's output, you should see something like
<code>/tmp/11468/1.txt:1:main</code>.
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Create index</h3>
<div class="outline-text-3" id="text-3-2">


<p>
In your source code directory, using android as example: 
</p>



<pre class="src src-sh"><span class="org-builtin">cd</span> ~/src/android
mkbeagrepidx
</pre>


<p>
This step will cost you quite some time, under my Linux indexing
Android cost me about half an hour (it's about the same time you run
grep directly on android source). So I'd advise you create a cron job
to do it at midnight.
</p>
<p>
It takes about 8 minutes to index linux kernel (v3.6-rc6):
</p>



<pre class="example">Debug: IndexWorker Done
Debug: Elapsed time 478.01s.
</pre>


<p>
But the good news is if indexing has already been done before, there
re-indexing will only work on those updated files based on file
time-stamp. So it will cost you only a few minutes to re-index the
whole Android source.
</p>
<p>
Even better, after an initial indexing, you can do a sub-folder
re-index, <code>mkbeagrepidx</code> will ask you if you want to update the index
found for upper directory. This generally only takes seconds depending
on the size of the sub-folder.
</p>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Man page for mkbeagrepidx</h3>
<div class="outline-text-3" id="text-3-3">


<p>
mkbeagrepidx is a simple wrapper over beagrep-build-index. You can
configure it for which directories to ignore using
<code>--deny-directory-pattern</code> option. By default,
</p>
<ul>
<li>The <code>$PWD/out</code> is ignored, because it contains android build output
</li>
<li>The */.git is ignored, because of well known reason
</li>
<li>The */.repo is ignored, for the same reason.
</li>
</ul>


<p>
The syntax is comma separated shell glob patterns, and you can check
how it is converted into regular expression by examining the beginning
of mkbeagrepidx output:
</p>



<pre class="example">Always: Will ignore directories matching regular expression: ^(?:/home/bhj/tmp/test/out)$|^(?:.*/\.repo)$|^(?:.*/\.git)$
</pre>


<p>
You can customize it using several ways, in the order of increasing
priority:
</p>
<ul>
<li>Not customize it, then the default




<pre class="example">"$PWD/out,*/.repo,*/.git"
</pre>


<p>  
  will be used.
</p>
</li>
<li>Override it in <code>/.mkbeagrepidx.rc, setting the ~BEAGREP_IGNORE_DIR_PATTERNS</code> environment variable:




<pre class="src src-sh"><span class="org-builtin">export</span> <span class="org-variable-name">BEAGREP_IGNORE_DIR_PATTERNS</span>=<span class="org-string">"$PWD/out,*/.repo,*/.git"</span>
</pre>


</li>
<li>Override it in the .mkbeagrepidx.rc in the current working directory, same as the above.

</li>
<li>Override it on the command line (you must repeat the default pattern
  because it won't append):




<pre class="src src-sh">mkbeagrepidx --deny-directory-pattern <span class="org-string">"$PWD/out,*/.repo,*/.git,*/.svn"</span>
</pre>

</li>
</ul>



</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Searching using beagrep</h3>
<div class="outline-text-3" id="text-3-4">


<p>
Under your source code directory:
</p>


<pre class="src src-sh"><span class="org-builtin">cd</span> ~/src/android
beagrep -e <span class="org-string">"readlink"</span>
</pre>



</div>

<div id="outline-container-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> Man page for beagrep</h4>
<div class="outline-text-4" id="text-3-4-1">


<p>
Here's a list of all arguments that beagrep takes:
</p>



<pre class="example">beagrep -e REGEXP_MATCH [-p REGEXP_PATH] [-a ADDITIONAL_WORDS] [-v REGEXP_REVERSE_PATH] [-i] [-f] [-l] [--grep GREP_OPTIONS] [-a]
</pre>


<dl>
<dt>-e <code>REGEXP_MATCH</code></dt><dd>This is the minimum required arguments. For e.g., <code>beagrep -e readlink</code>

<p>
     The <code>REGEXP_MATCH</code> serves 2 purposes:
</p>
<ul>
<li>First, it is computed into whole words for querying beagle. For
       e.g., <code>l] [--grep GREP_OPTIONS]</code> above should be matched with
       the following REGEXP: <code>l\] \[--grep GREP_OPTIONS\]</code>, but it
       should be converted into 4 words: <code>l grep GREP OPTIONS</code> for
       beagle.

</li>
<li>Second, it is used as the regexp for grep to work on.

</li>
</ul>

</dd>
<dt>-a <code>ADDITIONAL_WORDS</code></dt><dd>means to add more words into the beagle
     query. This is useful by increasing the work beagle need to do,
     but reduce the possible work set grep need to work on.

</dd>
<dt>-p <code>REGEXP_PATH</code></dt><dd>means to limit the search result to those files whose path-name matches <code>REGEXP_PATH</code>.

</dd>
<dt>-v <code>REGEXP_REVERSE_PATH</code></dt><dd>means to exclude those matched files whose path-name matches <code>REGEXP_REVERSE_PATH</code>.

</dd>
<dt>-i</dt><dd>means to do case insignificant grep.

</dd>
<dt>-f</dt><dd>means to do the match in file-names only. For example, <code>beagrep         -e readlink -f</code> will only show results like readlink.h and
        readlink.c.

<p>
        This is very useful for finding files. Note that when <code>-f</code> is
        used, the beagle querying words will be computed differently:
        only the basename will be used, and <code>filename:</code> is prepended
        onto each words.
</p>
</dd>
<dt>-l</dt><dd>means to list the beagle matched list of files directly, without running grep to match on them.

</dd>
<dt>&ndash;grep <code>GREP_OPTIONS</code></dt><dd>means to pass additional arguments to the
     grep invocation. For e.g., the <code>-l</code> argument can be passed to
     beagrep directly, or it can be passed using <code>--grep</code>, they mean different things:

<p>
     <code>beagrep -e "hello world" -l</code> will show a file containing "hello
     wonderful world", but <code>beagrep -e "hello world" --grep -l</code> will
     not show that file as a match.
</p></dd>
</dl>



</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> How does it work?</h2>
<div class="outline-text-2" id="text-4">


<p>
beagrep is a very practical software, it works because of the following observations:
</p>

</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> grep patterns are usually simple</h3>
<div class="outline-text-3" id="text-4-1">


<p>
Or rather, they can be decomposed into several simple sub-patterns: whole words.
</p>
<p>
For example, to grep such a seemingly complex pattern in Android source code:
</p>



<pre class="example">"JsonToValue(\"\\\\\"hello world\\\\\"\","
</pre>


<p>
In fact, it contained some simpler sub-patterns, i.e., those 3
wholesome English words: <code>JsonToValue</code> <code>hello</code> <code>world</code>. For a file to
match this complex pattern, one necessary but not sufficient condition
is for this file to contain all these 3 words. And what is good for
this job? A search engine! Using beagle, the parent project for
beagrep, a desktop search engine, you can find which files (actually,
which file in this case) contained these 3 words in a blink of the
eyes.
</p>
<p>
Only 1 file contained all 3 words:
</p>



<pre class="example">$beagrep-files 'JsonToValue hello world '
Beagrep index found at /home/bhj/tmp/for-code-reading//home/bhj/src/gingerbread-tegra/.beagrep
/home/bhj/src/gingerbread-tegra/external/chromium/base/json/json_reader_unittest.cc
/dev/null
</pre>


<p>
So, you can imagine how quick it is to run <code>grep</code> on the set of files containing all required words:
</p>



<pre class="example">beagrep -e "JsonToValue(\"\\\\\"hello world\\\\\"\","
pat is: 'JsonToValue("\\"hello world\\"",'.
beagrep query argument `JsonToValue hello world '
Beagrep index found at /home/bhj/tmp/for-code-reading//home/bhj/src/gingerbread-tegra/.beagrep
/home/bhj/src/gingerbread-tegra/external/chromium/base/json/json_reader_unittest.cc:168:  root.reset(JSONReader().JsonToValue("\"hello world\"", false, false));
Unmatched ( in regex; marked by &lt;-- HERE in m/JsonToValue( &lt;-- HERE ""hello world"",/ at /home/bhj/bin/beagrep line 98.
</pre>


<p>
To summarize, complete words are what search engines are good for, and
fortunately, when grepping source code, we almost always grep using
whole words, instead of sub-words. For e.g., this evil pattern
<code>r.*e.*a.*d.*l.*i.*n.*k</code> can match our <code>readlink</code>, but do you really
need that power of <code>grep</code>?
</p>

</div>

<div id="outline-container-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> BTW, creating the regexp pattern automatically in Emacs</h4>
<div class="outline-text-4" id="text-4-1-1">


<p>
From the example above, you can see the actual matched string is:
</p>



<pre class="example">JsonToValue("\"hello world\"",
</pre>


<p>
but because of meta characters in regexp and shell, the regexp pattern for beagrep to work on is a lot more complex:
</p>



<pre class="example">"JsonToValue(\"\\\\\"hello world\\\\\"\","
</pre>


<p>
It'd be tragedy if you need type all those <code>\</code> characters by
yourself. So of course I didn't. In fact, when you work in Emacs,
after you marked some text and press <code>C-u M-x grep</code>, Emacs will
correctly add the <code>\</code> -s for you, to convert this plain text into a
matching regexp (which can be passed to grep by the shell).
</p>
<p>
Note that last time I checked, the Emacs grep regexp generation code
has some bugs, so I rolled my own fix for it, you can check my <a href="https://github.com/baohaojun/windows-config/raw/master/.emacs">.emacs</a>
for definition of <code>grep-default-command</code> and
<code>grep-shell-quote-argument</code>.
</p>
</div>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> grep keywords are usually interesting</h3>
<div class="outline-text-3" id="text-4-2">


<p>
beagrep can greatly quicken the speed of grep, only because it can
greatly reduce the working set of files for grep.
</p>
<p>
Note that you need provide interesting words to search for so as to
<b>greatly</b> reduce the working set. By interesting I mean non-common.
</p>
<p>
For e.g., say you want to grep <code>is</code>. This word is so common in English
that almost all files would probably contain it (source code file will
probably contain it in comments). Then you are basically running grep
nakedly on the whole android source.
</p>
<p>
Fortunately, this requirement is easy to meet. In the first place, you
probably don't want to grep for common words; and even if you do need
to, you probably won't grep for one common word <b>alone</b>, which is very
uninteresting; thirdly, even if you do need to <code>grep</code> for a common
word alone, you can provide more words for <code>beagrep</code> to work on by
using its <code>-a</code> option (see the manpage above).
</p>
<p>
So:
</p>
<ul>
<li>Don't grep for <code>include</code> alone, because almost all C/C++ source and
  header files contain it.

</li>
<li>Don't grep for <code>import</code> alone, because almost all java source files
  contain it.
</li>
</ul>


<p>
And so on.
</p>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Other projects using beagrep</h2>
<div class="outline-text-2" id="text-5">


<p>
Because beagrep is so fast, I have used it in a couple other projects/tools.
</p>

</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> offline Wikipedia</h3>
<div class="outline-text-3" id="text-5-1">


<p>
I added CJK character support into beagrep so that both English and
Chinese offline Wikipedia can be browsed and subject-searched.
</p>
<p>
Check it out at <a href="https://github.com/baohaojun/windows-config">https://github.com/baohaojun/windows-config</a>, sorry I
didn't make it a stand-alone project, it's under the
<code>gcode/offline.wikipedia</code> directory.
</p>
</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> <code>grep-func-call</code> and <code>grep-func-call-all</code></h3>
<div class="outline-text-3" id="text-5-2">


<p>
The latter used beagrep and ctags-exuberant to search for which
functions called a specific function. It's under the <code>bin/</code> directory.
</p>
</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Generate call graph</h3>
<div class="outline-text-3" id="text-5-3">


<p>
This is a tool to generate a call graph for the software project you
want. I have found its effectiveness is to be questioned, but you can
see a picture below:
</p>
<p>
<img src="./call-graph.png"  alt="./call-graph.png" />
</p>
<p>
This picture is generated for the adb sub-project in android code. You
can see which functions are calling <code>adb_connect</code>, and which functions
are called by it.
</p>
<p>
It is generated using beagrep + ctags-exuberant + graphviz, using my
wrap scripts like following in the android/system/core directory:
</p>



<pre class="src src-sh">generate-call-graph.pl &gt; call_graph.org
dot-partition.pl call_graph.dot -s adb_connect -m 1 -r 2 
</pre>

</div>
</div>
</div>
</div>

<div id="postamble">
    <hr/>
    <div style="float:left;width:160px;">
    <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1611427581&verifier=936f3b91&dpc=1"></iframe>
    </div>
    <div id="jiathis_style_32x32" style="float:left;margin-left:20px;margin-top:35px;">
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_douban"></a>
        <a class="jiathis_button_tqq"></a>
        <a class="jiathis_button_renren"></a>
        <a class="jiathis_button_douban9dian"></a>
        <!--<a class="jiathis_button_readitlater"></a>-->
        <!--<a class="jiathis_button_instapaper"></a>-->
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <!--<a class="jiathis_counter_style"></a>-->
    </div>
<script type="text/javascript">
    $(document).ready(function(){
        BYB.includeScript('http://v2.jiathis.com/code/jia.js',function(){})
    });
</script>


</div>
</body>
</html>
