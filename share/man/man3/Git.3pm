.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Git 3pm"
.TH Git 3pm "2014-12-19" "perl v5.20.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Git \- Perl interface to the Git version control system
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Git;
\&
\&  my $version = Git::command_oneline(\*(Aqversion\*(Aq);
\&
\&  git_cmd_try { Git::command_noisy(\*(Aqupdate\-server\-info\*(Aq) }
\&              \*(Aq%s failed w/ code %d\*(Aq;
\&
\&  my $repo = Git\->repository (Directory => \*(Aq/srv/git/cogito.git\*(Aq);
\&
\&
\&  my @revs = $repo\->command(\*(Aqrev\-list\*(Aq, \*(Aq\-\-since=last monday\*(Aq, \*(Aq\-\-all\*(Aq);
\&
\&  my ($fh, $c) = $repo\->command_output_pipe(\*(Aqrev\-list\*(Aq, \*(Aq\-\-since=last monday\*(Aq, \*(Aq\-\-all\*(Aq);
\&  my $lastrev = <$fh>; chomp $lastrev;
\&  $repo\->command_close_pipe($fh, $c);
\&
\&  my $lastrev = $repo\->command_oneline( [ \*(Aqrev\-list\*(Aq, \*(Aq\-\-all\*(Aq ],
\&                                        STDERR => 0 );
\&
\&  my $sha1 = $repo\->hash_and_insert_object(\*(Aqfile.txt\*(Aq);
\&  my $tempfile = tempfile();
\&  my $size = $repo\->cat_blob($sha1, $tempfile);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides Perl scripts easy way to interface the Git version control
system. The modules have an easy and well-tested way to call arbitrary Git
commands; in the future, the interface will also provide specialized methods
for doing easily operations which are not totally trivial to do over
the generic command interface.
.PP
While some commands can be executed outside of any context (e.g. 'version'
or 'init'), most operations require a repository context, which in practice
means getting an instance of the Git object using the \fIrepository()\fR constructor.
(In the future, we will also get a \fInew_repository()\fR constructor.) All commands
called as methods of the object are then executed in the context of the
repository.
.PP
Part of the \*(L"repository state\*(R" is also information about path to the attached
working copy (unless you work with a bare repository). You can also navigate
inside of the working copy using the \f(CW\*(C`wc_chdir()\*(C'\fR method. (Note that
the repository object is self-contained and will not change working directory
of your process.)
.PP
\&\s-1TODO:\s0 In the future, we might also do
.PP
.Vb 3
\&        my $remoterepo = $repo\->remote_repository (Name => \*(Aqcogito\*(Aq, Branch => \*(Aqmaster\*(Aq);
\&        $remoterepo ||= Git\->remote_repository (\*(Aqhttp://git.or.cz/cogito.git/\*(Aq);
\&        my @refs = $remoterepo\->refs();
.Ve
.PP
Currently, the module merely wraps calls to external Git tools. In the future,
it will provide a much faster way to interact with Git by linking directly
to libgit. This should be completely opaque to the user, though (performance
increase notwithstanding).
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "repository ( \s-1OPTIONS \s0)" 4
.IX Item "repository ( OPTIONS )"
.PD 0
.IP "repository ( \s-1DIRECTORY \s0)" 4
.IX Item "repository ( DIRECTORY )"
.IP "repository ()" 4
.IX Item "repository ()"
.PD
Construct a new repository object.
\&\f(CW\*(C`OPTIONS\*(C'\fR are passed in a hash like fashion, using key and value pairs.
Possible options are:
.Sp
\&\fBRepository\fR \- Path to the Git repository.
.Sp
\&\fBWorkingCopy\fR \- Path to the associated working copy; not strictly required
as many commands will happily crunch on a bare repository.
.Sp
\&\fBWorkingSubdir\fR \- Subdirectory in the working copy to work inside.
Just left undefined if you do not want to limit the scope of operations.
.Sp
\&\fBDirectory\fR \- Path to the Git working directory in its usual setup.
The \f(CW\*(C`.git\*(C'\fR directory is searched in the directory and all the parent
directories; if found, \f(CW\*(C`WorkingCopy\*(C'\fR is set to the directory containing
it and \f(CW\*(C`Repository\*(C'\fR to the \f(CW\*(C`.git\*(C'\fR directory itself. If no \f(CW\*(C`.git\*(C'\fR
directory was found, the \f(CW\*(C`Directory\*(C'\fR is assumed to be a bare repository,
\&\f(CW\*(C`Repository\*(C'\fR is set to point at it and \f(CW\*(C`WorkingCopy\*(C'\fR is left undefined.
If the \f(CW$GIT_DIR\fR environment variable is set, things behave as expected
as well.
.Sp
You should not use both \f(CW\*(C`Directory\*(C'\fR and either of \f(CW\*(C`Repository\*(C'\fR and
\&\f(CW\*(C`WorkingCopy\*(C'\fR \- the results of that are undefined.
.Sp
Alternatively, a directory path may be passed as a single scalar argument
to the constructor; it is equivalent to setting only the \f(CW\*(C`Directory\*(C'\fR option
field.
.Sp
Calling the constructor with no options whatsoever is equivalent to
calling it with \f(CW\*(C`Directory => \*(Aq.\*(Aq\*(C'\fR. In general, if you are building
a standard porcelain command, simply doing \f(CW\*(C`Git\->repository()\*(C'\fR should
do the right thing and setup the object to reflect exactly where the user
is right now.
.SH "METHODS"
.IX Header "METHODS"
.IP "command ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute the given Git \f(CW\*(C`COMMAND\*(C'\fR (specify it without the 'git\-'
prefix), optionally with the specified extra \f(CW\*(C`ARGUMENTS\*(C'\fR.
.Sp
The second more elaborate form can be used if you want to further adjust
the command execution. Currently, only one option is supported:
.Sp
\&\fB\s-1STDERR\s0\fR \- How to deal with the command's error output. By default (\f(CW\*(C`undef\*(C'\fR)
it is delivered to the caller's \f(CW\*(C`STDERR\*(C'\fR. A false value (0 or '') will cause
it to be thrown away. If you want to process it, you can get it in a filehandle
you specify, but you must be extremely careful; if the error output is not
very short and you want to read it in the same process as where you called
\&\f(CW\*(C`command()\*(C'\fR, you are set up for a nice deadlock!
.Sp
The method can be called without any instance or on a specified Git repository
(in that case the command will be run in the repository context).
.Sp
In scalar context, it returns all the command output in a single string
(verbatim).
.Sp
In array context, it returns an array containing lines printed to the
command's stdout (without trailing newlines).
.Sp
In both cases, the command's stdin and stderr are the same as the caller's.
.IP "command_oneline ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_oneline ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command_oneline ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute the given \f(CW\*(C`COMMAND\*(C'\fR in the same way as \fIcommand()\fR
does but always return a scalar string containing the first line
of the command's standard output.
.IP "command_output_pipe ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_output_pipe ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command_output_pipe ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute the given \f(CW\*(C`COMMAND\*(C'\fR in the same way as \fIcommand()\fR
does but return a pipe filehandle from which the command output can be
read.
.Sp
The function can return \f(CW\*(C`($pipe, $ctx)\*(C'\fR in array context.
See \f(CW\*(C`command_close_pipe()\*(C'\fR for details.
.IP "command_input_pipe ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_input_pipe ( COMMAND [, ARGUMENTS... ] )"
.PD 0
.IP "command_input_pipe ( [ \s-1COMMAND, ARGUMENTS... \s0], { Opt => Val ... } )" 4
.IX Item "command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )"
.PD
Execute the given \f(CW\*(C`COMMAND\*(C'\fR in the same way as \fIcommand_output_pipe()\fR
does but return an input pipe filehandle instead; the command output
is not captured.
.Sp
The function can return \f(CW\*(C`($pipe, $ctx)\*(C'\fR in array context.
See \f(CW\*(C`command_close_pipe()\*(C'\fR for details.
.IP "command_close_pipe ( \s-1PIPE\s0 [, \s-1CTX \s0] )" 4
.IX Item "command_close_pipe ( PIPE [, CTX ] )"
Close the \f(CW\*(C`PIPE\*(C'\fR as returned from \f(CW\*(C`command_*_pipe()\*(C'\fR, checking
whether the command finished successfully. The optional \f(CW\*(C`CTX\*(C'\fR argument
is required if you want to see the command name in the error message,
and it is the second value returned by \f(CW\*(C`command_*_pipe()\*(C'\fR when
called in array context. The call idiom is:
.Sp
.Vb 3
\&        my ($fh, $ctx) = $r\->command_output_pipe(\*(Aqstatus\*(Aq);
\&        while (<$fh>) { ... }
\&        $r\->command_close_pipe($fh, $ctx);
.Ve
.Sp
Note that you should not rely on whatever actually is in \f(CW\*(C`CTX\*(C'\fR;
currently it is simply the command name but in future the context might
have more complicated structure.
.IP "command_bidi_pipe ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )"
Execute the given \f(CW\*(C`COMMAND\*(C'\fR in the same way as \fIcommand_output_pipe()\fR
does but return both an input pipe filehandle and an output pipe filehandle.
.Sp
The function will return return \f(CW\*(C`($pid, $pipe_in, $pipe_out, $ctx)\*(C'\fR.
See \f(CW\*(C`command_close_bidi_pipe()\*(C'\fR for details.
.IP "command_close_bidi_pipe ( \s-1PID, PIPE_IN, PIPE_OUT\s0 [, \s-1CTX\s0] )" 4
.IX Item "command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )"
Close the \f(CW\*(C`PIPE_IN\*(C'\fR and \f(CW\*(C`PIPE_OUT\*(C'\fR as returned from \f(CW\*(C`command_bidi_pipe()\*(C'\fR,
checking whether the command finished successfully. The optional \f(CW\*(C`CTX\*(C'\fR
argument is required if you want to see the command name in the error message,
and it is the fourth value returned by \f(CW\*(C`command_bidi_pipe()\*(C'\fR.  The call idiom
is:
.Sp
.Vb 4
\&        my ($pid, $in, $out, $ctx) = $r\->command_bidi_pipe(\*(Aqcat\-file \-\-batch\-check\*(Aq);
\&        print $out "000000000\en";
\&        while (<$in>) { ... }
\&        $r\->command_close_bidi_pipe($pid, $in, $out, $ctx);
.Ve
.Sp
Note that you should not rely on whatever actually is in \f(CW\*(C`CTX\*(C'\fR;
currently it is simply the command name but in future the context might
have more complicated structure.
.Sp
\&\f(CW\*(C`PIPE_IN\*(C'\fR and \f(CW\*(C`PIPE_OUT\*(C'\fR may be \f(CW\*(C`undef\*(C'\fR if they have been closed prior to
calling this function.  This may be useful in a query-response type of
commands where caller first writes a query and later reads response, eg:
.Sp
.Vb 5
\&        my ($pid, $in, $out, $ctx) = $r\->command_bidi_pipe(\*(Aqcat\-file \-\-batch\-check\*(Aq);
\&        print $out "000000000\en";
\&        close $out;
\&        while (<$in>) { ... }
\&        $r\->command_close_bidi_pipe($pid, $in, undef, $ctx);
.Ve
.Sp
This idiom may prevent potential dead locks caused by data sent to the output
pipe not being flushed and thus not reaching the executed command.
.IP "command_noisy ( \s-1COMMAND\s0 [, \s-1ARGUMENTS... \s0] )" 4
.IX Item "command_noisy ( COMMAND [, ARGUMENTS... ] )"
Execute the given \f(CW\*(C`COMMAND\*(C'\fR in the same way as \fIcommand()\fR does but do not
capture the command output \- the standard output is not redirected and goes
to the standard output of the caller application.
.Sp
While the method is called \fIcommand_noisy()\fR, you might want to as well use
it for the most silent Git commands which you know will never pollute your
stdout but you want to avoid the overhead of the pipe setup when calling them.
.Sp
The function returns only after the command has finished running.
.IP "version ()" 4
.IX Item "version ()"
Return the Git version in use.
.IP "exec_path ()" 4
.IX Item "exec_path ()"
Return path to the Git sub-command executables (the same as
\&\f(CW\*(C`git \-\-exec\-path\*(C'\fR). Useful mostly only internally.
.IP "html_path ()" 4
.IX Item "html_path ()"
Return path to the Git html documentation (the same as
\&\f(CW\*(C`git \-\-html\-path\*(C'\fR). Useful mostly only internally.
.IP "get_tz_offset ( \s-1TIME \s0)" 4
.IX Item "get_tz_offset ( TIME )"
Return the time zone offset from \s-1GMT\s0 in the form +/\-HHMM where \s-1HH\s0 is
the number of hours from \s-1GMT\s0 and \s-1MM\s0 is the number of minutes.  This is
the equivalent of what strftime(\*(L"%z\*(R", ...) would provide on a \s-1GNU\s0
platform.
.Sp
If \s-1TIME\s0 is not supplied, the current local time is used.
.IP "prompt ( \s-1PROMPT , ISPASSWORD  \s0)" 4
.IX Item "prompt ( PROMPT , ISPASSWORD )"
Query user \f(CW\*(C`PROMPT\*(C'\fR and return answer from user.
.Sp
Honours \s-1GIT_ASKPASS\s0 and \s-1SSH_ASKPASS\s0 environment variables for querying
the user. If no *_ASKPASS variable is set or an error occoured,
the terminal is tried as a fallback.
If \f(CW\*(C`ISPASSWORD\*(C'\fR is set and true, the terminal disables echo.
.IP "repo_path ()" 4
.IX Item "repo_path ()"
Return path to the git repository. Must be called on a repository instance.
.IP "wc_path ()" 4
.IX Item "wc_path ()"
Return path to the working copy. Must be called on a repository instance.
.IP "wc_subdir ()" 4
.IX Item "wc_subdir ()"
Return path to the subdirectory inside of a working copy. Must be called
on a repository instance.
.IP "wc_chdir ( \s-1SUBDIR \s0)" 4
.IX Item "wc_chdir ( SUBDIR )"
Change the working copy subdirectory to work within. The \f(CW\*(C`SUBDIR\*(C'\fR is
relative to the working copy root directory (not the current subdirectory).
Must be called on a repository instance attached to a working copy
and the directory must exist.
.IP "config ( \s-1VARIABLE \s0)" 4
.IX Item "config ( VARIABLE )"
Retrieve the configuration \f(CW\*(C`VARIABLE\*(C'\fR in the same manner as \f(CW\*(C`config\*(C'\fR
does. In scalar context requires the variable to be set only one time
(exception is thrown otherwise), in array context returns allows the
variable to be set multiple times and returns all the values.
.IP "config_bool ( \s-1VARIABLE \s0)" 4
.IX Item "config_bool ( VARIABLE )"
Retrieve the bool configuration \f(CW\*(C`VARIABLE\*(C'\fR. The return value
is usable as a boolean in perl (and \f(CW\*(C`undef\*(C'\fR if it's not defined,
of course).
.IP "config_path ( \s-1VARIABLE \s0)" 4
.IX Item "config_path ( VARIABLE )"
Retrieve the path configuration \f(CW\*(C`VARIABLE\*(C'\fR. The return value
is an expanded path or \f(CW\*(C`undef\*(C'\fR if it's not defined.
.IP "config_int ( \s-1VARIABLE \s0)" 4
.IX Item "config_int ( VARIABLE )"
Retrieve the integer configuration \f(CW\*(C`VARIABLE\*(C'\fR. The return value
is simple decimal number.  An optional value suffix of 'k', 'm',
or 'g' in the config file will cause the value to be multiplied
by 1024, 1048576 (1024^2), or 1073741824 (1024^3) prior to output.
It would return \f(CW\*(C`undef\*(C'\fR if configuration variable is not defined,
.IP "get_colorbool ( \s-1NAME \s0)" 4
.IX Item "get_colorbool ( NAME )"
Finds if color should be used for NAMEd operation from the configuration,
and returns boolean (true for \*(L"use color\*(R", false for \*(L"do not use color\*(R").
.IP "get_color ( \s-1SLOT, COLOR \s0)" 4
.IX Item "get_color ( SLOT, COLOR )"
Finds color for \s-1SLOT\s0 from the configuration, while defaulting to \s-1COLOR,\s0
and returns the \s-1ANSI\s0 color escape sequence:
.Sp
.Vb 3
\&        print $repo\->get_color("color.interactive.prompt", "underline blue white");
\&        print "some text";
\&        print $repo\->get_color("", "normal");
.Ve
.IP "remote_refs ( \s-1REPOSITORY\s0 [, \s-1GROUPS\s0 [, \s-1REFGLOBS \s0] ] )" 4
.IX Item "remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )"
This function returns a hashref of refs stored in a given remote repository.
The hash is in the format \f(CW\*(C`refname =\e\*(C'\fR hash>. For tags, the \f(CW\*(C`refname\*(C'\fR entry
contains the tag object while a \f(CW\*(C`refname^{}\*(C'\fR entry gives the tagged objects.
.Sp
\&\f(CW\*(C`REPOSITORY\*(C'\fR has the same meaning as the appropriate \f(CW\*(C`git\-ls\-remote\*(C'\fR
argument; either a \s-1URL\s0 or a remote name (if called on a repository instance).
\&\f(CW\*(C`GROUPS\*(C'\fR is an optional arrayref that can contain 'tags' to return all the
tags and/or 'heads' to return all the heads. \f(CW\*(C`REFGLOB\*(C'\fR is an optional array
of strings containing a shell-like glob to further limit the refs returned in
the hash; the meaning is again the same as the appropriate \f(CW\*(C`git\-ls\-remote\*(C'\fR
argument.
.Sp
This function may or may not be called on a repository instance. In the former
case, remote names as defined in the repository are recognized as repository
specifiers.
.IP "ident ( \s-1TYPE\s0 | \s-1IDENTSTR \s0)" 4
.IX Item "ident ( TYPE | IDENTSTR )"
.PD 0
.IP "ident_person ( \s-1TYPE\s0 | \s-1IDENTSTR\s0 | \s-1IDENTARRAY \s0)" 4
.IX Item "ident_person ( TYPE | IDENTSTR | IDENTARRAY )"
.PD
This suite of functions retrieves and parses ident information, as stored
in the commit and tag objects or produced by \f(CW\*(C`var GIT_type_IDENT\*(C'\fR (thus
\&\f(CW\*(C`TYPE\*(C'\fR can be either \fIauthor\fR or \fIcommitter\fR; case is insignificant).
.Sp
The \f(CW\*(C`ident\*(C'\fR method retrieves the ident information from \f(CW\*(C`git var\*(C'\fR
and either returns it as a scalar string or as an array with the fields parsed.
Alternatively, it can take a prepared ident string (e.g. from the commit
object) and just parse it.
.Sp
\&\f(CW\*(C`ident_person\*(C'\fR returns the person part of the ident \- name and email;
it can take the same arguments as \f(CW\*(C`ident\*(C'\fR or the array returned by \f(CW\*(C`ident\*(C'\fR.
.Sp
The synopsis is like:
.Sp
.Vb 4
\&        my ($name, $email, $time_tz) = ident(\*(Aqauthor\*(Aq);
\&        "$name <$email>" eq ident_person(\*(Aqauthor\*(Aq);
\&        "$name <$email>" eq ident_person($name);
\&        $time_tz =~ /^\ed+ [+\-]\ed{4}$/;
.Ve
.IP "hash_object ( \s-1TYPE, FILENAME \s0)" 4
.IX Item "hash_object ( TYPE, FILENAME )"
Compute the \s-1SHA1\s0 object id of the given \f(CW\*(C`FILENAME\*(C'\fR considering it is
of the \f(CW\*(C`TYPE\*(C'\fR object type (\f(CW\*(C`blob\*(C'\fR, \f(CW\*(C`commit\*(C'\fR, \f(CW\*(C`tree\*(C'\fR).
.Sp
The method can be called without any instance or on a specified Git repository,
it makes zero difference.
.Sp
The function returns the \s-1SHA1\s0 hash.
.IP "hash_and_insert_object ( \s-1FILENAME \s0)" 4
.IX Item "hash_and_insert_object ( FILENAME )"
Compute the \s-1SHA1\s0 object id of the given \f(CW\*(C`FILENAME\*(C'\fR and add the object to the
object database.
.Sp
The function returns the \s-1SHA1\s0 hash.
.IP "cat_blob ( \s-1SHA1, FILEHANDLE \s0)" 4
.IX Item "cat_blob ( SHA1, FILEHANDLE )"
Prints the contents of the blob identified by \f(CW\*(C`SHA1\*(C'\fR to \f(CW\*(C`FILEHANDLE\*(C'\fR and
returns the number of bytes printed.
.IP "credential_read( \s-1FILEHANDLE \s0)" 4
.IX Item "credential_read( FILEHANDLE )"
Reads credential key-value pairs from \f(CW\*(C`FILEHANDLE\*(C'\fR.  Reading stops at \s-1EOF\s0 or
when an empty line is encountered.  Each line must be of the form \f(CW\*(C`key=value\*(C'\fR
with a non-empty key.  Function returns hash with all read values.  Any white
space (other than new-line character) is preserved.
.IP "credential_write( \s-1FILEHANDLE, CREDENTIAL_HASHREF \s0)" 4
.IX Item "credential_write( FILEHANDLE, CREDENTIAL_HASHREF )"
Writes credential key-value pairs from hash referenced by
\&\f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR to \f(CW\*(C`FILEHANDLE\*(C'\fR.  Keys and values cannot contain
new-lines or \s-1NUL\s0 bytes characters, and key cannot contain equal signs nor be
empty (if they do Error::Simple is thrown).  Any white space is preserved.  If
value for a key is \f(CW\*(C`undef\*(C'\fR, it will be skipped.
.Sp
If \f(CW\*(Aqurl\*(Aq\fR key exists it will be written first.  (All the other key-value
pairs are written in sorted order but you should not depend on that).  Once
all lines are written, an empty line is printed.
.IP "credential( \s-1CREDENTIAL_HASHREF\s0 [, \s-1OPERATION \s0] )" 4
.IX Item "credential( CREDENTIAL_HASHREF [, OPERATION ] )"
.PD 0
.IP "credential( \s-1CREDENTIAL_HASHREF, CODE \s0)" 4
.IX Item "credential( CREDENTIAL_HASHREF, CODE )"
.PD
Executes \f(CW\*(C`git credential\*(C'\fR for a given set of credentials and specified
operation.  In both forms \f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR needs to be a reference to
a hash which stores credentials.  Under certain conditions the hash can
change.
.Sp
In the first form, \f(CW\*(C`OPERATION\*(C'\fR can be \f(CW\*(Aqfill\*(Aq\fR, \f(CW\*(Aqapprove\*(Aq\fR or \f(CW\*(Aqreject\*(Aq\fR,
and function will execute corresponding \f(CW\*(C`git credential\*(C'\fR sub-command.  If
it's omitted \f(CW\*(Aqfill\*(Aq\fR is assumed.  In case of \f(CW\*(Aqfill\*(Aq\fR the values stored in
\&\f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR will be changed to the ones returned by the \f(CW\*(C`git
credential fill\*(C'\fR command.  The usual usage would look something like:
.Sp
.Vb 12
\&        my %cred = (
\&                \*(Aqprotocol\*(Aq => \*(Aqhttps\*(Aq,
\&                \*(Aqhost\*(Aq => \*(Aqexample.com\*(Aq,
\&                \*(Aqusername\*(Aq => \*(Aqbob\*(Aq
\&        );
\&        Git::credential \e%cred;
\&        if (try_to_authenticate($cred{\*(Aqusername\*(Aq}, $cred{\*(Aqpassword\*(Aq})) {
\&                Git::credential \e%cred, \*(Aqapprove\*(Aq;
\&                ... do more stuff ...
\&        } else {
\&                Git::credential \e%cred, \*(Aqreject\*(Aq;
\&        }
.Ve
.Sp
In the second form, \f(CW\*(C`CODE\*(C'\fR needs to be a reference to a subroutine.  The
function will execute \f(CW\*(C`git credential fill\*(C'\fR to fill the provided credential
hash, then call \f(CW\*(C`CODE\*(C'\fR with \f(CW\*(C`CREDENTIAL_HASHREF\*(C'\fR as the sole argument.  If
\&\f(CW\*(C`CODE\*(C'\fR's return value is defined, the function will execute \f(CW\*(C`git credential
approve\*(C'\fR (if return value yields true) or \f(CW\*(C`git credential reject\*(C'\fR (if return
value is false).  If the return value is undef, nothing at all is executed;
this is useful, for example, if the credential could neither be verified nor
rejected due to an unrelated network error.  The return value is the same as
what \f(CW\*(C`CODE\*(C'\fR returns.  With this form, the usage might look as follows:
.Sp
.Vb 11
\&        if (Git::credential {
\&                \*(Aqprotocol\*(Aq => \*(Aqhttps\*(Aq,
\&                \*(Aqhost\*(Aq => \*(Aqexample.com\*(Aq,
\&                \*(Aqusername\*(Aq => \*(Aqbob\*(Aq
\&        }, sub {
\&                my $cred = shift;
\&                return !!try_to_authenticate($cred\->{\*(Aqusername\*(Aq},
\&                                             $cred\->{\*(Aqpassword\*(Aq});
\&        }) {
\&                ... do more stuff ...
\&        }
.Ve
.IP "temp_acquire ( \s-1NAME \s0)" 4
.IX Item "temp_acquire ( NAME )"
Attempts to retrieve the temporary file mapped to the string \f(CW\*(C`NAME\*(C'\fR. If an
associated temp file has not been created this session or was closed, it is
created, cached, and set for autoflush and binmode.
.Sp
Internally locks the file mapped to \f(CW\*(C`NAME\*(C'\fR. This lock must be released with
\&\f(CW\*(C`temp_release()\*(C'\fR when the temp file is no longer needed. Subsequent attempts
to retrieve temporary files mapped to the same \f(CW\*(C`NAME\*(C'\fR while still locked will
cause an error. This locking mechanism provides a weak guarantee and is not
threadsafe. It does provide some error checking to help prevent temp file refs
writing over one another.
.Sp
In general, the File::Handle returned should not be closed by consumers as
it defeats the purpose of this caching mechanism. If you need to close the temp
file handle, then you should use File::Temp or another temp file faculty
directly. If a handle is closed and then requested again, then a warning will
issue.
.IP "temp_is_locked ( \s-1NAME \s0)" 4
.IX Item "temp_is_locked ( NAME )"
Returns true if the internal lock created by a previous \f(CW\*(C`temp_acquire()\*(C'\fR
call with \f(CW\*(C`NAME\*(C'\fR is still in effect.
.Sp
When temp_acquire is called on a \f(CW\*(C`NAME\*(C'\fR, it internally locks the temporary
file mapped to \f(CW\*(C`NAME\*(C'\fR.  That lock will not be released until \f(CW\*(C`temp_release()\*(C'\fR
is called with either the original \f(CW\*(C`NAME\*(C'\fR or the File::Handle that was
returned from the original call to temp_acquire.
.Sp
Subsequent attempts to call \f(CW\*(C`temp_acquire()\*(C'\fR with the same \f(CW\*(C`NAME\*(C'\fR will fail
unless there has been an intervening \f(CW\*(C`temp_release()\*(C'\fR call for that \f(CW\*(C`NAME\*(C'\fR
(or its corresponding File::Handle that was returned by the original
\&\f(CW\*(C`temp_acquire()\*(C'\fR call).
.Sp
If true is returned by \f(CW\*(C`temp_is_locked()\*(C'\fR for a \f(CW\*(C`NAME\*(C'\fR, an attempt to
\&\f(CW\*(C`temp_acquire()\*(C'\fR the same \f(CW\*(C`NAME\*(C'\fR will cause an error unless
\&\f(CW\*(C`temp_release\*(C'\fR is first called on that \f(CW\*(C`NAME\*(C'\fR (or its corresponding
File::Handle that was returned by the original \f(CW\*(C`temp_acquire()\*(C'\fR call).
.IP "temp_release ( \s-1NAME \s0)" 4
.IX Item "temp_release ( NAME )"
.PD 0
.IP "temp_release ( \s-1FILEHANDLE \s0)" 4
.IX Item "temp_release ( FILEHANDLE )"
.PD
Releases a lock acquired through \f(CW\*(C`temp_acquire()\*(C'\fR. Can be called either with
the \f(CW\*(C`NAME\*(C'\fR mapping used when acquiring the temp file or with the \f(CW\*(C`FILEHANDLE\*(C'\fR
referencing a locked temp file.
.Sp
Warns if an attempt is made to release a file that is not locked.
.Sp
The temp file will be truncated before being released. This can help to reduce
disk I/O where the system is smart enough to detect the truncation while data
is in the output buffers. Beware that after the temp file is released and
truncated, any operations on that file may fail miserably until it is
re-acquired. All contents are lost between each release and acquire mapped to
the same string.
.IP "temp_reset ( \s-1FILEHANDLE \s0)" 4
.IX Item "temp_reset ( FILEHANDLE )"
Truncates and resets the position of the \f(CW\*(C`FILEHANDLE\*(C'\fR.
.IP "temp_path ( \s-1NAME \s0)" 4
.IX Item "temp_path ( NAME )"
.PD 0
.IP "temp_path ( \s-1FILEHANDLE \s0)" 4
.IX Item "temp_path ( FILEHANDLE )"
.PD
Returns the filename associated with the given tempfile.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
All functions are supposed to throw Perl exceptions in case of errors.
See the Error module on how to catch those. Most exceptions are mere
Error::Simple instances.
.PP
However, the \f(CW\*(C`command()\*(C'\fR, \f(CW\*(C`command_oneline()\*(C'\fR and \f(CW\*(C`command_noisy()\*(C'\fR
functions suite can throw \f(CW\*(C`Git::Error::Command\*(C'\fR exceptions as well: those are
thrown when the external command returns an error code and contain the error
code as well as access to the captured command's output. The exception class
provides the usual \f(CW\*(C`stringify\*(C'\fR and \f(CW\*(C`value\*(C'\fR (command's exit code) methods and
in addition also a \f(CW\*(C`cmd_output\*(C'\fR method that returns either an array or a
string with the captured command output (depending on the original function
call context; \f(CW\*(C`command_noisy()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR) and $<cmdline> which
returns the command and its arguments (but without proper quoting).
.PP
Note that the \f(CW\*(C`command_*_pipe()\*(C'\fR functions cannot throw this exception since
it has no idea whether the command failed or not. You will only find out
at the time you \f(CW\*(C`close\*(C'\fR the pipe; if you want to have that automated,
use \f(CW\*(C`command_close_pipe()\*(C'\fR, which can throw the exception.
.IP "git_cmd_try { \s-1CODE \s0} \s-1ERRMSG\s0" 4
.IX Item "git_cmd_try { CODE } ERRMSG"
This magical statement will automatically catch any \f(CW\*(C`Git::Error::Command\*(C'\fR
exceptions thrown by \f(CW\*(C`CODE\*(C'\fR and make your program die with \f(CW\*(C`ERRMSG\*(C'\fR
on its lips; the message will have \f(CW%s\fR substituted for the command line
and \f(CW%d\fR for the exit status. This statement is useful mostly for producing
more user-friendly error messages.
.Sp
In case of no exception caught the statement returns \f(CW\*(C`CODE\*(C'\fR's return value.
.Sp
Note that this is the only auto-exported function.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2006 by Petr Baudis <pasky@suse.cz>.
.PP
This module is free software; it may be used, copied, modified
and distributed under the terms of the \s-1GNU\s0 General Public Licence,
either version 2, or (at your option) any later version.
