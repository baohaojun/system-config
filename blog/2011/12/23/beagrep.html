<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>beagrep, grep 2G source code in 0.23 second</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Bao Haojun" />
<link rel="stylesheet" href="/css/default.css" type="text/css" />
 <link rel="shortcut icon" href="/poison.png" type="image/png" />

    <script type="text/javascript" src="/js/jquery-1.7.1.min.js"></script>
    <script type="text/javascript">
        var BYB = {};
    </script>
    <script type="text/javascript">
        BYB.includeScript = function(file,callback){
            var _doc = document.getElementsByTagName('head')[0];
            var js = document.createElement('script');
            js.setAttribute('type', 'text/javascript');
            js.setAttribute('src', file);
            _doc.appendChild(js);

            if (!/*@cc_on!@*/0) { //if not IE
                //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
                js.onload = function () {
                    callback();
                }
            } else {
                //IE6、IE7 support js.onreadystatechange
                js.onreadystatechange = function () {
                    if (js.readyState == 'loaded' || js.readyState == 'complete') {
                        callback();
                    }
                }
            }
            return false;
        }
    </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="header">

  <h1 id="blog-title">

    包昊军的博客

  </h1>
  <p id="description">What you don't know, won't hurt you.</p>

</div>
</div>
<div id='bhj_article'>
  <div id='bhj_leftpane'>
<div id="content">
<h1 class="title">beagrep, grep 2G source code in 0.23 second</h1>
<p>
Beagrep can grep <code>readlink</code> in Android source code in <del>0.8</del> 0.23<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> second when
cache is hot, and about 11 seconds when cache is cold.
</p>

<p>
Using <a href="https://github.com/ggreer/the_silver_searcher">ag</a> or <a href="https://github.com/petdance/ack">ack</a> or bare grep, the results are a couple of seconds when
cache is hot, or a couple of minutes when the cache is cold<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
I still remember when I read the ``Linux Device Drivers'', 1st Edition, in the preface, the author says:
</p>

<blockquote>
<p>
&#x2026; The text you are approaching is the result of hours of patient grepping &#x2026;
</p>
</blockquote>

<p>
I have been using grep to read source code ever since. It's been
adequate for a long time, until I started reading Android source code
with it. I remember vividly how it took me 30 minutes<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>
to <code>grep readlink</code> in Android source code (with VCS directory and
binary files excluded).
</p>

<p>
Then I learned about the beagle software which is a desktop search
engine, and it occurred to me, what if I use beagle and grep together?
I mean, to use beagle first to decide the (relatively a lot smaller)
set of possible matching files (i.e., files that contained the word
<code>readlink</code>, taking the previous example), then invoke grep on this set
only. Usually the job can be done in the blink of an eye.
</p>

<p>
Beagrep is available on GNU/Linux, Mac OS (requires MacPorts) and
Windows (requires CYGWIN). It also works with CJK characters
correctly, as long as the document is in utf8.
</p>

<p>
Because beagrep is so fast, I have also developped some more use cases
besides simply grepping through Android source code, for e.g., finding
function call sites.
</p>

<p>
There are other tools similar to beagrep, discussed at the end of this
blog.
</p>

<p>
(Note a Chinese version of this page is available <a href="../../../2012/01/31/beagrep-cn.html">here</a>, but it may be
outdated).
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Install</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Linux install</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> Using .deb under debian/ubuntu</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
<b>Update (2014-05-03)</b> I found that building and installing the lastest
version of beagrep deb package will sometimes cause runtime exception
when running on Ubuntu 12.04. So you are encouraged to build and
install from source code directly, which does not show this problem.
</p>

<p>
I have provided several .deb package files on github, one for debian
testing, 3 for ubuntu lucid(10.04), oneiric(11.10) and
precise(12.04). They are all for amd64. If you happen to be using one
of these, you can download them <a href="https://github.com/baohaojun/beagrep/downloads">here</a>. Here's how to install it using
ubuntu 12.04 as an example. After you have downloaded the .deb file:
</p>

<div class="org-src-container">

<pre class="src src-sh">dpkg -i beagrep-for-ubuntu-precise-2012-09-05-ae0a1a2.deb
<span class="org-comment-delimiter"># </span><span class="org-comment">The above step will probably get dependency errors, so you fix it:</span>
apt-get -f install
<span class="org-comment-delimiter"># </span><span class="org-comment">This will install the dependence packages.</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2"><span class="section-number-4">2.1.2</span> Compile by yourself</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
If you need compile by yourself, using Ubuntu precise as an example:
</p>

<div class="org-src-container">

<pre class="src src-sh">git clone https://github.com/baohaojun/beagrep.git -b for-ubuntu-precise
<span class="org-comment-delimiter"># </span><span class="org-comment">you can also run "git branch -a" to see other versions of debian/ubuntu supported</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Install build dependencies. You can open debian/control and check</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">the build dependencies and install all of them. The following</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">command will try to install them automatically, but if it fails then</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">you need figure out which packages to install manually. Good luck!</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">Or you can contact some debian/ubuntu advanced user for help.</span>
apt-get install $(<span class="org-sh-quoted-exec">cat</span> debian/control | perl -ne <span class="org-string">'print if m/Build-Depends/..m/Standards-Version/'</span>|grep -v -e Build-Depends:<span class="org-string">\\\|</span>Standards-Version|perl -npe <span class="org-string">'s/,/ /g'</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">do the build</span>
(<span class="org-builtin">set</span> -e; autoreconf -i; ./configure; make -j4; sudo make install; <span class="org-builtin">echo</span> OK)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3"><span class="section-number-4">2.1.3</span> Build .deb by yourself</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
<b>Update (2014-05-03)</b> I found that building and installing the lastest
version of beagrep deb package will sometimes cause runtime exception
when running on Ubuntu 12.04. So you are encouraged to build and
install from source code directly, which does not show this problem.
</p>

<p>
Before someone volunteer to make beagrep into debian/ubuntu
distribution, you might also find a need to build .deb by yourself
(for e.g., to help your colleagues use beagrep easily without needing
to compile it themselves).
</p>

<p>
Here's how I do it:
</p>

<ol class="org-ol">
<li>Make sure you can compile beagrep manually by referring to the
previous section.
</li>

<li>Make a tar.gz of beagrep (note that the filename must be exact, it
is required by dpkg):

<pre class="example">
tar czfv ~/.cache/beagrep_0.4.0.orig.tar.gz beagrep --exclude-vcs
</pre>
</li>

<li>Untar it and build the .deb package:

<pre class="example">
cd ~/tmp
tar zxfv beagrep_0.4.0.orig.tar.gz
cd beagrep
dpkg-buildpackage
</pre>

<p>
The .deb file is generated in the <code>~/tmp</code> directory.
</p>
</li>

<li>Refer to <i>#using.deb</i> for how to install.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Windows install</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Windows install can only be done compiling by yourself, and be
pre-warned, it's not easy&#x2026;
</p>
</div>

<div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> Install dependencies</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
You need install CYGWIN, Mono and sqlite for Windows.
</p>

<p>
For cygwin, you will need the following packages as the minimum (there
might be more, though I have tested these should be enough):
</p>

<pre class="example">
nc util-linux git vim rsync inetutils apache2 shutdown make
gnome-common gcc-core gcc-g++ mingw-gcc-core mingw-gcc-g++
mingw64-i686-gcc-core mingw64-i686-gcc-g++
mingw64-x86_64-gcc-core mingw64-x86_64-gcc-g++ screen
cygutils-extra procps wget git-svn
</pre>


<p>
(see <a href="https://github.com/baohaojun/system-config/raw/master/bin/windows/after-check-out.sh">after-check-out.sh</a> for how I installed these packages automatically).
</p>

<p>
For Mono, default download and install from mono project website is OK.
</p>

<p>
For sqlite, you need download the .zip file for Windows and extract
the .dll into your $PATH.
</p>
</div>
</div>

<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> Get beagrep Windows code</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">

<pre class="src src-sh">git clone git://github.com/baohaojun/beagrep.git -b for-windows
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> Compile and install</h4>
<div class="outline-text-4" id="text-2-2-3">
<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> beagrep
bash build-win.sh <span class="org-string">"/cygdrive/c/Program Files (x86)/Mono-3.2.3"</span>
</pre>
</div>

<p>
Now, the argument to build-win.sh is the folder where I have installed
mono, on my windows7, it is <code>/cygdrive/c/Program Files
(x86)/Mono-3.2.3</code>. One thing very important in building and using
beagrep on Windows is to get the directory name format correct,
because Windows has very weird characters in its pathname, <code>:</code> and
<code>Space</code>, which is harmful for writing Makefile and Shell scripts,
respectively.
</p>
</div>

<ol class="org-ol"><li>Fixing errors during build<br  /><div class="outline-text-5" id="text-2-2-3-1">
<p>
Note that when you are building, compilation will fail complaining
<code>/usr/lib/gcc/i686-pc-mingw32/4.5.2/libstdc++.la</code> not found, this is
because it is specified in <code>C:/Program Files
(x86)/Mono-3.2.3/lib/pkgconfig/mono.pc</code>, and you need to edit this
file to remove it.
</p>
</div>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Usage</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Quick smoke test</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> /tmp; mkdir $<span class="org-variable-name">$</span>; <span class="org-builtin">cd</span> $<span class="org-variable-name">$</span>; <span class="org-builtin">echo</span> main &gt; 1.txt; mkbeagrepidx; beagrep -e <span class="org-string">'main'</span> --grep <span class="org-string">'--color=auto'</span>; true; <span class="org-builtin">cd</span> ..; rm $<span class="org-variable-name">$</span> -rf
</pre>
</div>

<p>
If beagrep has been installed correctly, at the end of the above
command's output, you should see something like
<code>/.cache/11468/1.txt:1:main</code>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Create index</h3>
<div class="outline-text-3" id="text-3-2">
<p>
In your source code directory, using android as example:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> ~/src/android
mkbeagrepidx
</pre>
</div>

<p>
This step will cost you quite some time, under my Linux indexing
Android cost me about half an hour (it's about the same time you run
grep directly on android source). So I'd advise you create a cron job
to do it at midnight.
</p>

<p>
It takes about 8 minutes to index linux kernel (v3.6-rc6):
</p>

<pre class="example">
Debug: IndexWorker Done
Debug: Elapsed time 478.01s.
</pre>

<p>
But the good news is if indexing has already been done before, there
re-indexing will only work on those updated files based on file
time-stamp. So it will cost you only a few minutes to re-index the
whole Android source.
</p>

<p>
Even better, after an initial indexing, you can do a sub-folder
re-index, <code>mkbeagrepidx</code> will ask you if you want to update the index
found for upper directory. This generally only takes seconds depending
on the size of the sub-folder.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Man page for mkbeagrepidx</h3>
<div class="outline-text-3" id="text-3-3">
<p>
mkbeagrepidx is a simple wrapper over beagrep-build-index. You can
configure it for which directories to ignore using
<code>--deny-directory-pattern</code> option. By default,
</p>

<ul class="org-ul">
<li>The <code>$PWD/out</code> is ignored, because it contains android build output
</li>
<li>The */.git is ignored, because of well known reason
</li>
<li>The */.repo is ignored, for the same reason.
</li>
</ul>

<p>
The syntax is comma separated shell glob patterns, and you can check
how it is converted into regular expression by examining the beginning
of mkbeagrepidx output:
</p>

<pre class="example">
Always: Will ignore directories matching regular expression: ^(?:/home/bhj/tmp/test/out)$|^(?:.*/\.repo)$|^(?:.*/\.git)$
</pre>

<p>
You can customize it using several ways, in the order of increasing
priority:
</p>

<ul class="org-ul">
<li>Not customize it, then the default

<pre class="example">
"$PWD/out,*/.repo,*/.git"
</pre>

<p>
will be used.
</p>
</li>

<li>Override it in <code>~/.mkbeagrepidx.rc</code>, setting the <code>BEAGREP_IGNORE_DIR_PATTERNS</code> environment variable:

<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">export</span> <span class="org-variable-name">BEAGREP_IGNORE_DIR_PATTERNS</span>=<span class="org-string">"$PWD/out,*/.repo,*/.git"</span>
</pre>
</div>
</li>

<li>Override it in the .mkbeagrepidx.rc in the current working directory, same as the above.
</li>

<li>Override it on the command line (you must repeat the default pattern
because it won't append):

<div class="org-src-container">

<pre class="src src-sh">mkbeagrepidx --deny-directory-pattern <span class="org-string">"$PWD/out,*/.repo,*/.git,*/.svn"</span>
</pre>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Searching using beagrep</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Under your source code directory:
</p>
<div class="org-src-container">

<pre class="src src-sh"><span class="org-builtin">cd</span> ~/src/android
beagrep -e <span class="org-string">"readlink"</span>
</pre>
</div>
</div>

<div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> Man page for beagrep</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
Here's a list of all arguments that beagrep takes:
</p>

<pre class="example">
beagrep -e REGEXP_MATCH [-p REGEXP_PATH] [-a ADDITIONAL_WORDS] [-v REGEXP_REVERSE_PATH] [-i] [-f] [-l] [--grep GREP_OPTIONS] [-a]
</pre>

<dl class="org-dl">
<dt> -e <code>REGEXP_MATCH</code> </dt><dd>This is the minimum required arguments. For e.g., <code>beagrep -e readlink</code>

<p>
The <code>REGEXP_MATCH</code> serves 2 purposes:
</p>

<ul class="org-ul">
<li>First, it is computed into whole words for querying beagle. For
e.g., <code>l] [--grep GREP_OPTIONS]</code> above should be matched with
the following REGEXP: <code>l\] \[--grep GREP_OPTIONS\]</code>, but it
should be converted into 4 words: <code>l grep GREP OPTIONS</code> for
beagle.
</li>

<li>Second, it is used as the regexp for grep to work on.
</li>
</ul>
</dd>

<dt> -a <code>ADDITIONAL_WORDS</code> </dt><dd>means to add more words into the beagle
query. This is useful by increasing the work beagle need to do,
but reduce the possible work set grep need to work on.
</dd>

<dt> -p <code>REGEXP_PATH</code> </dt><dd>means to limit the search result to those files whose path-name matches <code>REGEXP_PATH</code>.
</dd>

<dt> -v <code>REGEXP_REVERSE_PATH</code> </dt><dd>means to exclude those matched files whose path-name matches <code>REGEXP_REVERSE_PATH</code>.
</dd>

<dt> -i </dt><dd>means to do case insignificant grep.
</dd>

<dt> -f </dt><dd>means to do the match in file-names only. For example, <code>beagrep
        -e readlink -f</code> will only show results like readlink.h and
readlink.c.

<p>
This is very useful for finding files. Note that when <code>-f</code> is
used, the beagle querying words will be computed differently:
only the basename will be used, and <code>filename:</code> is prepended
onto each words.
</p>
</dd>

<dt> -l </dt><dd>means to list the beagle matched list of files directly, without running grep to match on them.
</dd>

<dt> &#x2013;grep <code>GREP_OPTIONS</code> </dt><dd>means to pass additional arguments to the
grep invocation. For e.g., the <code>-l</code> argument can be passed to
beagrep directly, or it can be passed using <code>--grep</code>, they mean different things:

<p>
<code>beagrep -e "hello world" -l</code> will show a file containing "hello
wonderful world", but <code>beagrep -e "hello world" --grep -l</code> will
not show that file as a match.
</p>
</dd>
</dl>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> How does it work?</h2>
<div class="outline-text-2" id="text-4">
<p>
beagrep is a very practical software, it works because of the following observations:
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> grep patterns are usually simple</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Or rather, they can be decomposed into several simple sub-patterns: whole words.
</p>

<p>
For example, to grep such a seemingly complex pattern in Android source code:
</p>

<pre class="example">
"JsonToValue(\"\\\\\"hello world\\\\\"\","
</pre>

<p>
In fact, it contained some simpler sub-patterns, i.e., those 3
wholesome English words: <code>JsonToValue</code> <code>hello</code> <code>world</code>. For a file to
match this complex pattern, one necessary but not sufficient condition
is for this file to contain all these 3 words. And what is good for
this job? A search engine! Using beagle, the parent project for
beagrep, a desktop search engine, you can find which files (actually,
which file in this case) contained these 3 words in the blink of an
eye.
</p>

<p>
Only 1 file contained all 3 words:
</p>

<pre class="example">
$beagrep-files 'JsonToValue hello world '
Beagrep index found at /home/bhj/.cache/for-code-reading//home/bhj/src/gingerbread-tegra/.beagrep
/home/bhj/src/gingerbread-tegra/external/chromium/base/json/json_reader_unittest.cc
/dev/null
</pre>

<p>
So, you can imagine how quick it is to run <code>grep</code> on the set of files containing all required words:
</p>


<pre class="example">
beagrep -e "JsonToValue(\"\\\\\"hello world\\\\\"\","
pat is: 'JsonToValue("\\"hello world\\"",'.
beagrep query argument `JsonToValue hello world '
Beagrep index found at /home/bhj/.cache/for-code-reading//home/bhj/src/gingerbread-tegra/.beagrep
/home/bhj/src/gingerbread-tegra/external/chromium/base/json/json_reader_unittest.cc:168:  root.reset(JSONReader().JsonToValue("\"hello world\"", false, false));
Unmatched ( in regex; marked by &lt;-- HERE in m/JsonToValue( &lt;-- HERE ""hello world"",/ at /home/bhj/bin/beagrep line 98.
</pre>

<p>
To summarize, complete words are what search engines are good for, and
fortunately, when grepping source code, we almost always grep using
whole words, instead of sub-words. For e.g., this evil pattern
<code>r.*e.*a.*d.*l.*i.*n.*k</code> can match our <code>readlink</code>, but do you really
need that power of <code>grep</code>?
</p>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> BTW, creating the regexp pattern automatically in Emacs</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
From the example above, you can see the actual matched string is:
</p>

<pre class="example">
JsonToValue("\"hello world\"",
</pre>

<p>
but because of meta characters in regexp and shell, the regexp pattern for beagrep to work on is a lot more complex:
</p>

<pre class="example">
"JsonToValue(\"\\\\\"hello world\\\\\"\","
</pre>

<p>
It'd be tragedy if you need type all those <code>\</code> characters by
yourself. So of course I didn't. In fact, when you work in Emacs,
after you marked some text and press <code>C-u M-x grep</code>, Emacs will
correctly add the <code>\</code> -s for you, to convert this plain text into a
matching regexp (which can be passed to grep by the shell).
</p>

<p>
Note that last time I checked, the Emacs grep regexp generation code
has some bugs, so I rolled my own fix for it, you can check my <a href="https://github.com/baohaojun/system-config/raw/master/.emacs">.emacs</a>
for definition of <code>grep-default-command</code> and
<code>grep-shell-quote-argument</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> grep keywords are usually interesting</h3>
<div class="outline-text-3" id="text-4-2">
<p>
beagrep can greatly quicken the speed of grep, only because it can
greatly reduce the working set of files for grep.
</p>

<p>
Note that you need provide interesting words to search for so as to
<b>greatly</b> reduce the working set. By interesting I mean non-common.
</p>

<p>
For e.g., say you want to grep <code>is</code>. This word is so common in English
that almost all files would probably contain it (source code file will
probably contain it in comments). Then you are basically running grep
nakedly on the whole android source.
</p>

<p>
Fortunately, this requirement is easy to meet. In the first place, you
probably don't want to grep for common words; and even if you do need
to, you probably won't grep for one common word <b>alone</b>, which is very
uninteresting; thirdly, even if you do need to <code>grep</code> for a common
word alone, you can provide more words for <code>beagrep</code> to work on by
using its <code>-a</code> option (see the manpage above).
</p>

<p>
So:
</p>

<ul class="org-ul">
<li>Don't grep for <code>include</code> alone, because almost all C/C++ source and
header files contain it.
</li>

<li>Don't grep for <code>import</code> alone, because almost all java source files
contain it.
</li>
</ul>

<p>
And so on.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Other projects using beagrep</h2>
<div class="outline-text-2" id="text-5">
<p>
Because beagrep is so fast, I have used it in a couple other projects/tools.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> offline Wikipedia</h3>
<div class="outline-text-3" id="text-5-1">
<p>
I added CJK character support into beagrep so that both English and
Chinese offline Wikipedia can be browsed and subject-searched.
</p>

<p>
Check it out at <a href="https://github.com/baohaojun/system-config">https://github.com/baohaojun/system-config</a>, sorry I
didn't make it a stand-alone project, it's under the
<code>gcode/offline.wikipedia</code> directory.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> <code>grep-func-call</code> and <code>grep-func-call-all</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
These 2 scripts generate the function usage relationship for easier
code reading. Given a function funcA, which is used in a bunch of other functions in the system, these 2 scripts work like this:
</p>

<ol class="org-ol">
<li>Use beagrep to find out in which files funcA appears.
</li>

<li>Run ctags-exuberant to tag these files, get the function definition
lines: In file FileF, funcB is defined on line N, funcC is defined
on line M, and no other functions are between N and M.
</li>

<li>If funcA appears in FileF, between line N and line M, then funcB
calls funcA. This is not precise, but it's good enough.
</li>

<li>It not only works with functions, but also with almost all complete
words that beagrep can handle.
</li>
</ol>

<p>
The first script works with the current Emacs buffer only, the 2nd
works system-wide, searching function call sites though out the whole
source repo.
</p>

<p>
See the following output, note that grep-mode is used for jumping
around, and <code>=&gt; and &lt;=</code> is used to denote the caller and caller:
</p>

<div class="org-src-container">

<pre class="src src-grepout">-*- mode: grep; default-directory: "~/src/android/kernel/drivers/staging/android/" -*-
Grep started at Mon Jun 30 13:18:42

grep-func-call -e "BINDER_WRITE_READ" --nc -a


Entering directory `<span class="org-function-name">/home/bhj/src/android/bionic/libc/kernel/common/linux</span>'
<span class="org-underline"><span class="org-compilation-info">binder.h</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">61</span></span><span class="org-underline">:</span> &lt;=  signed long protocol_version;
<span class="org-underline"><span class="org-compilation-info">binder.h</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">65</span></span><span class="org-underline">:</span> =&gt; #define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)
Entering directory `<span class="org-function-name">/home/bhj/src/android/external/kernel-headers/original/linux</span>'
<span class="org-underline"><span class="org-compilation-info">binder.h</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">81</span></span><span class="org-underline">:</span> &lt;=         signed long     protocol_version;
<span class="org-underline"><span class="org-compilation-info">binder.h</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">87</span></span><span class="org-underline">:</span> =&gt; #define BINDER_WRITE_READ               _IOWR('b', 1, struct binder_write_read)
Entering directory `<span class="org-function-name">/home/bhj/src/android/external/valgrind/main/coregrind/m_syswrap</span>'
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">4258</span></span><span class="org-underline">:</span> &lt;= PRE(sys_ioctl)
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5498</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_READ("ioctl(BINDER_WRITE_READ).write_buffer",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5500</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_READ("ioctl(BINDER_WRITE_READ).write_size",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5502</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_READ("ioctl(BINDER_WRITE_READ).write_consumed",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5504</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_READ("ioctl(BINDER_WRITE_READ).read_buffer",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5506</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_READ("ioctl(BINDER_WRITE_READ).read_size",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5508</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_READ("ioctl(BINDER_WRITE_READ).read_consumed",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5511</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_WRITE("ioctl(BINDER_WRITE_READ).write_consumed",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5513</span></span><span class="org-underline">:</span> =&gt;            PRE_FIELD_WRITE("ioctl(BINDER_WRITE_READ).read_consumed",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5517</span></span><span class="org-underline">:</span> =&gt;                PRE_MEM_WRITE("ioctl(BINDER_WRITE_READ).read_buffer[]",
<span class="org-underline"><span class="org-compilation-info">syswrap-linux.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">5520</span></span><span class="org-underline">:</span> =&gt;                PRE_MEM_READ("ioctl(BINDER_WRITE_READ).write_buffer[]",
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/native/cmds/servicemanager</span>'
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">142</span></span><span class="org-underline">:</span> &lt;= int binder_write(struct binder_state *bs, void *data, unsigned len)
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">152</span></span><span class="org-underline">:</span> =&gt;     res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">303</span></span><span class="org-underline">:</span> &lt;= int binder_call(struct binder_state *bs,
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">339</span></span><span class="org-underline">:</span> =&gt;         res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">357</span></span><span class="org-underline">:</span> &lt;= void binder_loop(struct binder_state *bs, binder_handler func)
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">375</span></span><span class="org-underline">:</span> =&gt;         res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);
Entering directory `<span class="org-function-name">/home/bhj/src/android/frameworks/native/libs/binder</span>'
<span class="org-underline"><span class="org-compilation-info">IPCThreadState.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">795</span></span><span class="org-underline">:</span> &lt;= status_t IPCThreadState::talkWithDriver(bool doReceive)
<span class="org-underline"><span class="org-compilation-info">IPCThreadState.cpp</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">848</span></span><span class="org-underline">:</span> =&gt;         if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
Entering directory `<span class="org-function-name">/home/bhj/src/android/kernel/drivers/staging/android</span>'
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">2690</span></span><span class="org-underline">:</span> &lt;= static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
<span class="org-underline"><span class="org-compilation-info">binder.c</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">2712</span></span><span class="org-underline">:</span> =&gt;       case BINDER_WRITE_READ: {
Entering directory `<span class="org-function-name">/home/bhj/src/android/kernel/drivers/staging/android</span>'
<span class="org-underline"><span class="org-compilation-info">binder.h</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">81</span></span><span class="org-underline">:</span> &lt;=         signed long     protocol_version;
<span class="org-underline"><span class="org-compilation-info">binder.h</span></span><span class="org-underline">:</span><span class="org-underline"><span class="org-compilation-line-number">87</span></span><span class="org-underline">:</span> =&gt; #define BINDER_WRITE_READ               _IOWR('b', 1, struct binder_write_read)

Grep finished (<span class="org-compilation-info">matches found</span>) at Mon Jun 30 13:18:46
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Generate call graph</h3>
<div class="outline-text-3" id="text-5-3">
<p>
This is a tool to generate a call graph for the software project you
want. I have found its effectiveness is to be questioned, but you can
see a picture below:
</p>


<div class="figure">
<p><a href="../../../../images/post/call-graph.png"><img src="../../../../images/post/call-graph.png" alt="call-graph.png" /></a>
</p>
</div>

<p>
This picture is generated for the adb sub-project in android code. You
can see which functions are calling <code>adb_connect</code>, and which functions
are called by it.
</p>

<p>
It is generated using beagrep + ctags-exuberant + graphviz, using my
wrap scripts like following in the android/system/core directory:
</p>

<div class="org-src-container">

<pre class="src src-sh">generate-call-graph.pl &gt; call_graph.org
dot-partition.pl call_graph.dot -s adb_connect -m 1 -r 2
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Other tools similar to beagrep</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Opengrok</h3>
<div class="outline-text-3" id="text-6-1">
<p>
<a href="https://blogs.oracle.com/chandan/entry/the_story_of_opengrok_the">This tool</a> is very much like beagrep, it also uses the Lucene search
engine! Beagrep uses beagle, which uses the C# implementation of
Lucene. I probably wouldn't start working on beagrep had I known
opengrok earlier. That said, I'm glad I have beagrep, because it is
Emacs friendlier:-)
</p>

<p>
I do not use opengrok myself since I have beagrep already, but you are
encouraged to try it out, it has quite a few nice features. Especially
if you do not use Emacs for reading and writing code.
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Ack/Ag</h3>
<div class="outline-text-3" id="text-6-2">
<p>
These 2 tools are faster grep, they do not use indexing. Author of Ack
has maintained a quite complete list of other grep-like tools at <a href="http://beyondgrep.com/more-tools/">this
web page</a>. Both opengrok and beagrep are listed there.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
Here's how I improved it from 0.8s to 0.23s: use Mono's
AOT option to do the JIT optimization Ahead Of Time. I found out about
this option when I was investigating why beagrep on my
MacbookAir+Linux is consistently a few tenths of second slower than
other machines, which is another story, see <a href="../../../2013/05/03/beagrep-even-faster2.html">beagrep performance tuning
on MacbookAir+Linux</a>.
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
Here's how I run <code>grep</code> in Android source tree: <code>time grep
          -I -r --exclude-dir=.git --exclude-dir=.repo -e readlink</code>
<code>~/src/android</code>. The first time it took 5m20s, second time
1m21s, and third time 3.5s, and it can't be reduced much
further. The result is retrieved on a ThinkPad T420 with 8G
memory. One thing notable here I think is that it could
require multiple runs to reach the minimum 3.5s. Another
thing is I tried it multiple times on my MacbookAir with
about the same debian installation, <code>grep</code> always takes
about 1m as the minimum. Was it because less memory (only 4G
for MacbookAir), or was it because SSD and thus different
caching strategy? It eludes me. (<b>EDIT</b>: it's because cpu
freq is locked at 800MHz, same as the above footnote, see
<a href="../../../2013/05/03/beagrep-even-faster2.html">beagrep performance tuning on MacbookAir+Linux</a>.)
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
As stated in the previous footnote, something must
have went wrong with this result, 30 minutes is just impossibly long
compared to the 5m20s cache cold and 3.5s cache hot stated above. Was
it because of a slower machine, or even being run within a virtual
machine (on a slower real machine)?  I can neither remember nor
reproduce now. But I think one problem was the way I used <code>grep</code>, it's
something along the line of: <code>find-filter-out-non-src-files | xargs
grep readlink</code>. This will cause a lot of <code>grep</code> processes to be
created because on most systems there is a max number of characters
(typically 128k on 32 bit systems) limit with the command line
arguments. When this limit is exceeded, you will see something like
<code>bash: XXX: Argument list too long</code>. For this reason, xargs will call
its command multiple times. For e.g., when I run this command: <code>seq 1
1000000 | xargs bash -c 'echo -n $#\ ' true</code>, you'd expect <code>1000000</code>
is printed, because xargs will pass this many arguments to the bash
command, but no, instead you will see (try it, see how slow it is!)
<code>23692 21841 21841 21841...</code> printed one by one because xargs must
invoke this bash command multiple times and each time pass just as
many arguments as possible. This is not the most efficient way for
calling grep (with all the arguments creating and passing around and
grep processes creating and exiting) and must have contributed to my
30 minutes measurement.
</p>
<nav>
  <ul id="prev_next_posts">
    <li class="prev_post">
      <a href="../../../../meta/Archive.html"> <!-- prev-url -->
        <i class="icon-chevron-left">《</i>
        Archive <!-- prev-title -->
      </a>
    </li>
    <li class="next_post" style="text-align: right;">
      <a href="index.html"> <!-- next-url -->
        My Page on Github <!-- next-title -->
        <i class="icon-chevron-right">》</i>
      </a>
    </li>
  </ul>
</nav></div>


</div>
</div></div>
<!-- {%html-mode%} -->

<div id="disqus_container">
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: THIS CODE IS ONLY AN EXAMPLE * * */
    var disqus_shortname = 'baohaojun'; // Required - Replace example with your forum shortname
    var disqus_url = 'http://baohaojun.github.io/blog/2011/12/23/beagrep.html';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
    <div style="margin-bottom:20px">
    <script type="text/javascript" charset="utf-8">
      (function(){
      var _w = 86 , _h = 16;
      var param = {
      url:location.href,
      type:'6',
      count:'', /**是否显示分享数，1显示(可选)*/
      appkey:'', /**您申请的应用appkey,显示分享来源(可选)*/
      title:'', /**分享的文字内容(可选，默认为所在页面的title)*/
      pic:'', /**分享图片的路径(可选)*/
      ralateUid:'1611427581', /**关联用户的UID，分享微博会@该用户(可选)*/
      language:'zh_cn', /**设置语言，zh_cn|zh_tw(可选)*/
      rnd:new Date().valueOf()
      }
      var temp = [];
      for( var p in param ){
      temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )
      }
      document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="'+ _w+'" height="'+_h+'"></iframe>')
      })()
    </script>
  </div>
  <div id="disqus_thread"></div>
</div>

</div> <!-- bhj_leftpane -->
<div id="sidebar"><div id="sidebar2">


  <!-- Begin #profile-container -->

   <div id="profile-container"><h2 class="sidebar-title">About Me</h2>
<dl class="profile-datablock"><dt class="profile-img"><a href="/images/bhj.png""><img src="/images/bhj-thumb.png" alt="My Photo" height="58" width="80"></a></dt>
<dd class="profile-data"><strong>Name:</strong> <a rel="author" href="https://www.github.com/baohaojun"> Bao Haojun </a></dd>
<dd class="profile-data"><strong>Location:</strong>  Beijing, China </dd></dl>

<p class="profile-link"><a rel="author" href="/blog/2011/12/23/index.html">View my complete profile</a></p></div>

  <!-- End #profile -->



  <h2 class="sidebar-title">Feeds</h2>
    <ul>
        <li><a href="/atom.xml">Atom</a></li>
    </ul>

  <h2 class="sidebar-title">Projects</h2>
    <dl>
        <dt><a href="/blog/2011/12/23/beagrep.html"> Beagrep </a></dt>
        <dd> Grep 2G source code in 0.23 second </dd>

        <dt><a href="/blog/2013/04/13/skeleton-complete.html"> Skeletom-complete.el </a></dt>
        <dd> Type a bare skeleton, complete to a symbol/partial line/sexp/paragraph </dd>

        <dt><a href="/blog/2011/12/28/org-jira.html"> Org-jira.el </a></dt>
        <dd> Use JIRA with org-mode </dd>
    </dl>

    <h2>Tags</h2>
    <ul>
                <li><a href="../../../../meta/tags/beagrep.html" title="Fastest grep">beagrep</a></li>
    </ul>

  <h2 class="sidebar-title">Previous Posts</h2>
    <ul id="recently">
        
    </ul>

    <h2 class="sidebar-title">Archive</h2>
      <ul id="archives">
        <li><a href="/meta/Archive.html"> The complete archive </a></li>
      </ul>

  <!--
  <p>This is a paragraph of text that could go in the sidebar.</p>
  -->



</div></div>
<!-- End #sidebar -->
</div> <!-- End #bhj_article -->
<!-- {%/html-mode%} -->
<div id="postamble" class="status">
<!-- {%html-mode%} -->

<!-- {%/html-mode%} -->
</div>
</body>
</html>
