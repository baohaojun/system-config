#!/bin/bash
set -e

set -e

me=$(readlink -f $0)
if test ! -e "$me"; then
    me=$(readlink -f "$(which $0)")
    if test ! -e "$me"; then
        die "Can't find out about me"
        exit 1
    fi
fi
b0=$(basename $0)

sol-help() {
    cat <<EOF
用法：$b0 选项... [命令（output-line）|参数（args）]...

这个命令有两个名字（类似于 busybox，根据名字不同调用不同的功能），一个
是 select-args，另一个是 select-output-line，前者让你从一长串参数选中一
个参数，后者让你从一长串输出中选出一行输出。

限制：select-args 的参数中不能包含换行符。

EOF
}

## start code-generator "^\\s *#\\s *"
    # generate-getopt -P '?"$(sol-help)"' \
    # O:order-name oORDERED='${SELECT_HISTORY_ORDER:-false}' '?"Should use history for list order"' \
    # s:select-dist-word='${SELECT_DIST_WORD:-not-set\!}' '?"选中参数的时候，按照与这个参数的字符串距离排序"' \
    # m:max-history=-1 '?"如果保存历史输入，最多保存几个历史输入，默认是无限"' \
    # a:always-selection '?"这个参数给出的选项，永远出现在列表里"' \
    # 1hint-1-entry '?"只有一个选项的时候，不用选，但要提示"' \
    # p:prompt='"Please enter your selection"' '?"让用户选择时给的提示"' \
    # i:init '?"初始输入的匹配字符串，跟它匹配才会列出"' \
    # @:dot-sep-init '?"用 . 把初始输入切割开"' \
    # @select-from-history-too '?"是否也允许从历史中选择（默认只从给定的参数、输出中选择）"' \
    # @:exclude '?"不要选中这个参数中给定的选项"' \
    # @use-file='${SA_USE_FILE:-false}' '?"把参数写到文件中，而不是从命令行上传递"' \
    # vverbose '?"调试选项，打印更多输出"' \
    # @ask-for-input '?"如果没有输入选项，直接调用 ask-for-input 程序让用户输入，一般跟 select-from-history-too 联用"'
## end code-generator
## start generated code
TEMP=$(POSIXLY_CORRECT=true getopt -o oa:1i:m:O:p:s:vh \
                      --long ORDERED,always-selection:,ask-for-input,dot-sep-init:,exclude:,hint-1-entry,init:,max-history:,order-name:,prompt:,select-dist-word:,select-from-history-too,use-file,verbose,help,no-ORDERED,no-ask-for-input,no-hint-1-entry,no-select-from-history-too,no-use-file,no-verbose \
                      -n $(basename -- $0) -- "$@")
declare ORDERED=${SELECT_HISTORY_ORDER:-false}
declare always_selection=
declare ask_for_input=false
declare dot_sep_init=
declare exclude=
declare hint_1_entry=false
declare init=
declare max_history=-1
declare order_name=
declare prompt="Please enter your selection"
declare select_dist_word=${SELECT_DIST_WORD:-not-set\!}
declare select_from_history_too=false
declare use_file=${SA_USE_FILE:-false}
declare verbose=false
eval set -- "$TEMP"
while true; do
    case "$1" in

        -o|--ORDERED|--no-ORDERED)
            if test "$1" = --no-ORDERED; then
                ORDERED=false
            else
                ORDERED=true
            fi
            shift

            ;;
        -a|--always-selection)
            always_selection=$2
            shift 2

            ;;
        --ask-for-input|--no-ask-for-input)
            if test "$1" = --no-ask-for-input; then
                ask_for_input=false
            else
                ask_for_input=true
            fi
            shift

            ;;
        --dot-sep-init)
            dot_sep_init=$2
            shift 2

            ;;
        --exclude)
            exclude=$2
            shift 2

            ;;
        -1|--hint-1-entry|--no-hint-1-entry)
            if test "$1" = --no-hint-1-entry; then
                hint_1_entry=false
            else
                hint_1_entry=true
            fi
            shift

            ;;
        -i|--init)
            init=$2
            shift 2

            ;;
        -m|--max-history)
            max_history=$2
            shift 2

            ;;
        -O|--order-name)
            order_name=$2
            shift 2

            ;;
        -p|--prompt)
            prompt=$2
            shift 2

            ;;
        -s|--select-dist-word)
            select_dist_word=$2
            shift 2

            ;;
        --select-from-history-too|--no-select-from-history-too)
            if test "$1" = --no-select-from-history-too; then
                select_from_history_too=false
            else
                select_from_history_too=true
            fi
            shift

            ;;
        --use-file|--no-use-file)
            if test "$1" = --no-use-file; then
                use_file=false
            else
                use_file=true
            fi
            shift

            ;;
        -v|--verbose|--no-verbose)
            if test "$1" = --no-verbose; then
                verbose=false
            else
                verbose=true
            fi
            shift

            ;;
        -h|--help)
            set +x
            echo -e "$(sol-help)"
            echo
            echo Options and arguments:
            printf %06s '-o, '
            printf %-24s '--[no-]ORDERED'
            echo "Should use history for list order"
            printf %06s '-a, '
            printf %-24s '--always-selection=ALWAYS_SELECTION'
            echo
            printf "%30s" ""
            echo "这个参数给出的选项，永远出现在列表里"
            printf "%06s" " "
            printf %-24s '--[no-]ask-for-input'
            echo "如果没有输入选项，直接调用 ask-for-input 程序让用户输入，一般跟 select-from-history-too 联用"
            printf "%06s" " "
            printf %-24s '--dot-sep-init=DOT_SEP_INIT'
            echo
            printf "%30s" ""
            echo "用 . 把初始输入切割开"
            printf "%06s" " "
            printf %-24s '--exclude=EXCLUDE'
            echo "不要选中这个参数中给定的选项"
            printf %06s '-1, '
            printf %-24s '--[no-]hint-1-entry'
            echo "只有一个选项的时候，不用选，但要提示"
            printf %06s '-i, '
            printf %-24s '--init=INIT'
            echo "初始输入的匹配字符串，跟它匹配才会列出"
            printf %06s '-m, '
            printf %-24s '--max-history=MAX_HISTORY'
            echo
            printf "%30s" ""
            echo "如果保存历史输入，最多保存几个历史输入，默认是无限"
            printf %06s '-O, '
            printf %-24s '--order-name=ORDER_NAME'
            echo
            printf %06s '-p, '
            printf %-24s '--prompt=PROMPT'
            echo "让用户选择时给的提示"
            printf %06s '-s, '
            printf %-24s '--select-dist-word=SELECT_DIST_WORD'
            echo
            printf "%30s" ""
            echo "选中参数的时候，按照与这个参数的字符串距离排序"
            printf "%06s" " "
            printf %-24s '--[no-]select-from-history-too'
            echo
            printf "%30s" ""
            echo "是否也允许从历史中选择（默认只从给定的参数、输出中选择）"
            printf "%06s" " "
            printf %-24s '--[no-]use-file'
            echo "把参数写到文件中，而不是从命令行上传递"
            printf %06s '-v, '
            printf %-24s '--[no-]verbose'
            echo "调试选项，打印更多输出"
            exit
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            die "internal error: $(. bt; echo; bt | indent-stdin)"
            ;;
    esac
done


## end generated code

if test "$always_selection"; then
    export always_selection
fi

export SELECT_PROMPT=$prompt
if test -z "$init" -a "$dot_sep_init"; then
    init=${dot_sep_init//./ }
fi
if test "$init"; then
    export ORIGINAL_MATCHER=$init
fi

if test "$order_name"; then
    ORDERED=$order_name
fi

if test "$select_from_history_too" = true -a "$ORDERED" = false; then
    ORDERED=true
fi

if test $ORDERED != false; then
    if test $ORDERED != true; then
        md5=$ORDERED
    else
        md5=$(echo $SELECT_PROMPT "$@" | md5sum | pn 1)
    fi
    cmdfile=~/.cache/system-config/bhj/select-output-line/$md5.cmd.$UID
    histfile=~/.cache/system-config/bhj/select-output-line/$md5.hist.$UID
    if test "$verbose" = true; then
        echo 1>&2 "Histfile is $histfile"
    fi
    mkdir -p $(dirname $cmdfile);
    (
        touch $histfile
        atomic-cp $histfile $histfile.$$
    ) >/dev/null 2>&1 || true

    echo "$@" > $cmdfile
fi

. aterr rm -f $histfile.$$

IFS=$'\n'
selection_entries=(
    $(
        tmpfile=/tmp/$(basename $0).$$
        (
            if test "$b0" = select-args; then
               for x in "$@"; do
                   echo "$x"
               done
            elif test $# = 1; then
                bash -c "$1"
            else
                "$@"
            fi | tr '\r' '\n' > $tmpfile

            if test $ORDERED != false; then
                common-lines-in-files $tmpfile $histfile.$$
            fi

            if test "$select_from_history_too" = true -a -e "$histfile"; then
                cat "$histfile"
            fi

            cat $tmpfile
            rm $tmpfile
        ) |
            if test "$ORDERED" != false; then
                if test "$select_dist_word" != 'not-set!'; then
                    (
                        uniq-and-dist-sort --keep 5 "$select_dist_word"
                    ) | uniq-even-non-ajacent
                else
                    uniq-even-non-ajacent
                fi
            elif test "$select_dist_word" != 'not-set!'; then
                uniq-and-dist-sort "$select_dist_word"
            else
                uniq-even-non-ajacent
            fi |
            if test -z "$exclude"; then
                cat
            else
                (
                    IFS=$'\t \n'
                    while read line; do
                        is_exclude=false
                        for e in $exclude; do
                            if test "$line" = "$e"; then
                                is_exclude=true
                                break
                            fi
                        done
                        if test "$is_exclude" = false; then
                            echo "$line"
                        fi
                    done
                )
            fi
    )
) || true

is-good-n() {
    true
}

if test ${#selection_entries[@]} = 0; then
    if test "${ask_for_input}" = true; then
        output=$(
            ask-for-input -p "${prompt}"
              )
    else
        exit 1
    fi
elif test "${#selection_entries[@]}" = 1 -a -z "${always_selection}" -a -z "$init"; then
    if test "$hint_1_entry" = true; then
        if test "${ask_for_input}" = true; then
            if yes-or-no-p -y "只有一个选项： ${selection_entries[0]}，确定？"; then
                echo -n "${selection_entries[0]}"
                exit 0
            else
                output=$(
                    ask-for-input -p "${prompt}"
                      )
            fi
        else
            hint "只有一个选项：${selection_entries[0]}"
        fi
    fi
    echo -n "${selection_entries[0]}"
    exit 0
else
    if test "${select_from_history_too}" = true; then
        edit_history="@@@edit the history file@@@"
        selection_entries+=("${edit_history}")
    fi
    n=$(my-select "${selection_entries[@]}")

    function is-good-n() {
        echo "$n" | grep -q -P -e '^[0-9]+$' && test "$n" -ge 1 -a $n -le ${#selection_entries[@]}
    }

    output=$(
        if is-good-n; then
            echo -n ${selection_entries[n-1]}
        else
            echo -n "$n"
        fi
          )

    if test "${select_from_history_too}" = true -a "$output" = "${edit_history}"; then
        ew $histfile
        exit 1
    fi
fi

echo -n "$output" | tr -d '\r'

if (  is-good-n && test "$ORDERED" != false ) || test "$select_from_history_too" = true; then
    (
        echo "$output"
        cat $histfile.$$ 2>/dev/null || true
    ) | perl -ne "print if 1..$max_history" | uniq-even-non-ajacent > $histfile.$$.2 &&
        mv $histfile.$$.2 $histfile && rm $histfile.$$ -f
fi&
