;;; nix-buffer-autoloads.el --- automatically extracted autoloads
;;
;;; Code:

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory #$) (car load-path))))


;;;### (autoloads nil "nix-buffer" "nix-buffer.el" (0 0 0 0))
;;; Generated autoloads from nix-buffer.el

(autoload 'nix-buffer "nix-buffer" "\
Set up the buffer according to the directory-local nix expression.
Looks for dir-locals.nix upward from the current directory.  If found,
asynchronously builds the derivation defined there with the 'root' arg
set to the current buffer file name or directory and evaluates the
resulting elisp if safe to do so.  'nix-buffer-after-load-hook' can be
used to detect when the elisp load occurs.

If we have previously built dir-locals.nix for the current file or
directory, the elisp corresponding to the last build is evaluated
synchronously and the new elisp is evaluated when the build completes,
unless the newly-built file is identical.  As such, the elisp
generated by dir-locals.nix should be written with multiple
evaluations in mind.

Because in practice dir-locals.nix will always want to do things that
are unsafe in dir-locals.el (e.g. append to 'exec-path'), we don't
reuse that mechanism and instead just load the file as elisp.  Because
this allows arbitrary code execution, the first time we're asked to
load a particular store path we query the user to verify if it's safe
to load beforehand.

The Lisp code generated by dir-locals.nix should limit itself to
modifying buffer-local variables, but there is no actual enforcement
of this.  'setq-local' is your friend.

If dir-locals.nix does not evaluate to any derivations (e.g. it
evaluates to {}), then nothing is loaded and the cached result, if any,
is removed." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nix-buffer" '("nix-buffer-")))

;;;***

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; coding: utf-8
;; End:
;;; nix-buffer-autoloads.el ends here
