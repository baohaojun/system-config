#+name: check-if-git-is-clean
#+BEGIN_SRC sh
  (
      if test "$DEBUG" = true; then
          set -x
          function git()
          {
              command git "$@" ||
                  {
                      case "$1" in
                          ,*)
                              echo $(pwd) git "$@" failed
                              ;;
                      esac
                  } 1>&2
          }
          export -f git
      fi
      set -- $($REPO_INFO remote branch path)
      remote=$1
      branch=$2
      path=$3
      if test ${#branch} = 40; then
          remote_rev=$branch
      elif [[ $branch =~ /tags/ ]]; then
          remote_rev=$(git rev-parse $branch)
      else
          remote_rev=$(git rev-parse $remote/$branch)
      fi

      if test -z "$GIT_END_DATE"; then
          rev=$(git rev-parse $remote_rev)
      else
          rev=$(git log --until="$GIT_END_DATE" -1 $remote_rev|head -n 1|pn 2)
      fi

      changed_files=$(git status -s | grep . || true)
      if test "$changed_files"; then
          n_changed=$(echo "$changed_files" | wc -l)
          echo "$path repo contains changs: '$(echo "$changed_files" | head -n 1)' ($n_changed changed files)"
      fi

      if test "$DO_GIT_ST_ONLY" = true; then
          exit 0
      fi

      # git status is clean, we need to check git revision and `git clean` output
      git_clean_output=$(
          git clean -xfdn 2>&1|grep -v '^Skipping repository |^Would skip repository' -P|grep .|head -n 1 || true
                      )
      if test "$git_clean_output"; then
          echo "$path need clean: $git_clean_output"
          exit
      fi

      head_rev=$(git rev-parse HEAD)

      if test "$head_rev" != "$rev"; then
          need_bail=true

          if test $need_bail = true; then
              if [[ $branch =~ /tags/ ]]; then
                  git fetch $remote $branch >/dev/null 2>&1
              else
                  git fetch $remote refs/heads/$branch >/dev/null 2>&1
              fi
              fetch_rev=$(git rev-parse FETCH_HEAD^0)

              if test "$head_rev" = "$fetch_rev"; then
                  need_bail=false
              fi
          fi

          if test $need_bail = true; then
              (
                  flock -x 10;
                  echo $path rev not the same;
              )
              exit

          fi
      fi
  ) || echo "$PWD git failed"



#+END_SRC
** 最终的版本：

#+name: read-only
#+BEGIN_SRC sh
# Local Variables: #
# eval: (read-only-mode 1) #
# End: #
#+END_SRC

#+name: old-code
#+BEGIN_SRC sh
  #!/bin/bash

  if test $(basename $0) = repo-not-clean; then
      export DO_GIT_ST_ONLY=true
  fi

  if echo $SHELLOPTS | grep -q xtrace; then
      export SHELLOPTS
  fi

  export path_pattern=
  export GIT_END_DATE=
  TEMP=$(getopt -o e:p: --long end:,pattern: -n $(basename $0) -- "$@")
  eval set -- "$TEMP"
  while true; do
      case "$1" in
          -e|--end)
              export GIT_END_DATE=$(day-end $2)
              shift 2
              ;;
          -p|--path)
              path_pattern=$2
              shift 2
              ;;
          --)
              shift
              break
              ;;
          *)
              die "internal error"
              ;;
      esac
  done

  if test "$1" = out/repo-changes.log; then
      cd $(lookup-file .repo/..)
  fi

  if test $# = 0 -a ! -d .repo; then
      set -- $(repo-top)/$(repo-path)
  fi

  set -- $(
      for x in "$@"; do
          echo -d "$x"
      done
  )

  my-rfa -j 4 -p "$path_pattern" "$@" -- "$(cat <<'EOF552bc89ae4fe'
<<check-if-git-is-clean>>
EOF552bc89ae4fe
)" 2>&1 10>~/.cache/system-config/logs/repo-changes.lock | (
      cd $(lookup-file .repo/..);
      mkdir -p $(readlink -m out)
      log=./out/repo-changes.log"$(echo -n $*)"
      lognow="$log-$(now)"
      tee "$lognow" 2>/dev/null
      ln -sf $(basename "$lognow") "$log" >/dev/null 2>&1
      cp "$log" .repo/repo-changes.log >/dev/null 2>&1
      ln -sf .repo/repo-changes.log
  )
#+END_SRC

#+name: the-ultimate-script
#+BEGIN_SRC sh :tangle ~/system-config/bin/repo-changes? :comments link :shebang "#!/bin/bash" :noweb yes
set -e

<<old-code>>
<<read-only>>
#+END_SRC

#+results: the-ultimate-script

