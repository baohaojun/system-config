
这个脚本尝试用 bash 的 =bind -x= 功能完成自定义的补齐功能。

主要解决的痛点是在 bash 有很多补齐候选项的时候，我可以自己定义如何进行这些选项的选择。目前市面上已有的做法是：

1. bash，先提示你一下，有很多候选项，你要不要全部显示？然后你选 Yes，显示全部候选项之后，再接着打字或改成用鼠标选中、拷贝、粘贴。

2. zsh，我自己没有用过，但之前有个同事给我演示过，允许把所有选项列出来，然后你可以用方向键上下左右移动高亮某选项，然后回车选中它。

我希望把它改成这样子：我按一个键后，马上调用我的 =my-select= （或 =select-args= 等）脚本，把所有选项列出来让我选，选完了之后直接上屏。

** 最终的版本：

#+name: read-only
#+BEGIN_SRC sh
# Local Variables: #
# eval: (read-only-mode 1) #
# End: #
#+END_SRC

#+name: old-code
#+BEGIN_SRC sh
  function sc-complete() {
      declare -x COMP_LINE=$READLINE_LINE
      declare -x COMP_POINT=$READLINE_POINT

      declare sc_line_before_point=${READLINE_LINE:0:$READLINE_POINT}
      declare sc_line_after_point=${READLINE_LINE:$READLINE_POINT}

      declare OLDIFS=$IFS
      IFS=$COMP_WORDBREAKS
      declare -a sc_comp_words_before_point=(
          $sc_line_before_point
      )

      declare -a sc_comp_words_after_point=(
          $sc_line_after_point
      )

      IFS=$OLDIFS

      declare sc_last_word_before_point

      if test ${#sc_comp_words_before_point[@]} -gt 0; then
          sc_last_word_before_point=${sc_comp_words_before_point[${#sc_comp_words_before_point[@]} - 1]}
      else
          sc_last_word_before_point=""
      fi


      if test "${sc_line_before_point:${#sc_line_before_point}-${#sc_last_word_before_point}}" != "${sc_last_word_before_point}"; then
          # There are other ``blank'' chars before the point, so there should be an empty WORD
          sc_comp_words_before_point=(
              "${sc_comp_words_before_point[@]}"
              ""
          )
      fi

      declare -x COMP_WORDS=(
          "${sc_comp_words_before_point[@]}"
          "${sc_comp_words_after_point[@]}"
      )

      declare -x COMP_CWORD=$((${#sc_comp_words_before_point[@]} - 1)) || true
      COMP_CWORD=$((COMP_CWORD < 0 ? 0 : COMP_CWORD))
      declare current_word=${COMP_WORDS[$COMP_CWORD]}
      declare -x COMP_KEY=9
      declare -x COMP_TYPE=9

      declare first_word=${COMP_WORDS[0]}
      declare cword_minus_1=$((COMP_CWORD > 0 ? COMP_CWORD - 1 : 0))

      declare comp_call_args=(
          "$first_word"
          "${COMP_WORDS[$COMP_CWORD]}"
          "${COMP_WORDS[$cword_minus_1]}"
      )



      declare complete_spec=
      declare -a COMPREPLY
      local IFS=$'\n'
      declare -A sc_comp_options

      if test "${#COMP_WORDS[@]}" -lt 1; then
          COMPREPLY=(
              $(compgen -c "$first_word")
          )
      else
          complete_spec=$(complete -p ${first_word} 2>/dev/null)
          if test -z "${complete_spec}"; then
              declare default_loader=$(complete -p -D | perl -ne 'print $1 if m/ (?:-F|-C) (\w+)/')
              if test "${default_loader}"; then
                  ${default_loader} "${comp_call_args[@]}"
              fi
              complete_spec=$(complete -p ${first_word} 2>/dev/null)
          fi

          if test "${complete_spec}"; then
              compopt() {
                  while test $# != 0; do
                      if test $1 = -o; then
                          sc_comp_options[${2:-unknown}]=1
                          shift 2
                      else
                          shift 1
                      fi
                  done
              }

              declare complete_action
              if echo "$complete_spec" | grep -P -q -e " -[FC] "; then
                  complete_action=$(echo "${complete_spec}" | perl -ne 'print $1 if m/ (?:-F|-C) (\w+)/')
              else
                  complete_action=$(echo "${complete_spec% ${first_word}}"|perl -pe 's,^complete ,compgen ,')
              fi

              if test "$(type -t "${complete_action}")" = function; then
                  ${complete_action} 2>/dev/null
              else
                  COMPREPLY=(
                      $( eval ${complete_action} 2>/dev/null)
                  )
              fi
              unset -f compopt
          fi
      fi

      if test "${#COMPREPLY[@]}" = 0 && (
              test -z "${complete_spec}" ||
                  [[ $complete_spec =~ '-o default' ]]
          ); then
          COMPREPLY=(
              $(
                  for x in "${COMP_WORDS[$COMP_CWORD]}"*; do
                      if test "${x}" != "${COMP_WORDS[$COMP_CWORD]}"\*; then
                          echo "${x}"
                      fi
                  done
              )
          )
      fi
      if test "${#COMPREPLY[@]}" = 0; then
          return
      fi
      declare comp_ans=$(. atexit stty -echo; stty echo; select-args -p "请选择你要哪个补齐？" -- "${COMPREPLY[@]}")
      if test "${sc_comp_options[filenames]}"; then
          if test -d "${comp_ans}"; then
              comp_ans=$comp_ans/
          fi
          comp_ans=$(printf %q "$comp_ans")
      fi
      READLINE_LINE=${sc_line_before_point%${current_word}}${comp_ans}
      READLINE_POINT=${#READLINE_LINE}
      READLINE_LINE=${READLINE_LINE}${sc_line_after_point}
  }

  bind -x '"\eOP": sc-complete'
#+END_SRC

#+name: the-ultimate-script
#+BEGIN_SRC sh :tangle ~/system-config/bin/sc-complete :comments link :shebang "#!/bin/bash" :noweb yes

<<old-code>>
<<read-only>>
#+END_SRC

#+results: the-ultimate-script

